{"meta":{"title":"派大星星星星","subtitle":"你有没有给我带点鱼来","description":null,"author":"大星","url":"https://paaatrick.com","root":"/"},"pages":[{"title":"所有分类","date":"2019-05-07T09:02:49.945Z","updated":"2019-05-07T09:02:49.945Z","comments":true,"path":"categories/index.html","permalink":"https://paaatrick.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-05-07T09:02:49.946Z","updated":"2019-05-07T09:02:49.946Z","comments":true,"path":"tags/index.html","permalink":"https://paaatrick.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode-bfs-dfs","slug":"leetcode-bfs-dfs","date":"2019-05-08T04:02:49.000Z","updated":"2019-05-08T09:59:26.662Z","comments":true,"path":"2019-05-08-leetcode-bfs-dfs/","link":"","permalink":"https://paaatrick.com/2019-05-08-leetcode-bfs-dfs/","excerpt":"有关BFS（广度优先）与DFS（深度优先）的做题笔记，Python实现 二叉树的定义123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 102. 二叉树的层次遍历 Binary Tree Level Order TraversalLeetCodeCN 第102题链接 第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，注意range(len(queue))使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度O(n)","text":"有关BFS（广度优先）与DFS（深度优先）的做题笔记，Python实现 二叉树的定义123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 102. 二叉树的层次遍历 Binary Tree Level Order TraversalLeetCodeCN 第102题链接 第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，注意range(len(queue))使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415161718192021222324import collectionsclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result = [] queue = collections.deque() queue.append(root) # 如果不是树而是图的话要记录一下访问过的节点，避免重复访问 # visited = set(root) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result 第二种方法：DFS深度优先搜索，利用递归的栈，借助level记号把节点放入对应层，由于每个节点仅访问一次，所以时间复杂度O(n) 12345678910111213141516class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] self.result = [] self._dfs(root, 0) return self.result def _dfs(self, node, level): if not node: return if len(self.result) &lt; level + 1: self.result.append([]) self.result[level].append(node.val) self._dfs(node.left, level + 1) self._dfs(node.right, level + 1) 104. 二叉树的最大深度 Maximum Depth of Binary Tree第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，range(len(queue))使只遍历当前的层，每次大循环ans加1。由于每个节点仅访问一次，所以时间复杂度O(n)1234567891011121314151617import collectionsclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 queue = collections.deque() queue.append(root) ans = 0 while queue: ans += 1 for _ in range(len(queue)): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return ans 第二种方法：DFS深度优先搜索，利用递归的栈，借助level标记当前层，由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 self.ans = 0 self._dfs(root, 0) return self.ans def _dfs(self, node, level): if not node: return if self.ans &lt; level + 1: self.ans = level + 1 self._dfs(node.left, level + 1) self._dfs(node.right, level + 1) 第三种方法：DFS+分治，虽然代码简洁但耗时比上面两种方法都久 12345class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) 111. 二叉树的最小深度 Minimum Depth of Binary Tree第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，range(len(queue))使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415161718import collectionsclass Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 ans = 0 queue = collections.deque() queue.append(root) while queue: ans += 1 for _ in range(len(queue)): node = queue.popleft() if node.left is None and node.right is None: return ans if node.left: queue.append(node.left) if node.right: queue.append(node.right) 第二种方法：DFS深度优先搜索，利用递归的栈，借助level标记当前层，由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415161718class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 self.ans = float('inf') self._dfs(root, 0) return self.ans def _dfs(self, node, level): if not node: return if node.left is None and node.right is None: if self.ans &gt; level + 1: self.ans = level + 1 return self._dfs(node.left, level + 1) self._dfs(node.right, level + 1)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—买卖股票的最佳时机系列题目","slug":"leetcode-best-time-to-buy-and-sell-stock-series","date":"2019-05-07T13:34:40.000Z","updated":"2019-05-08T09:59:09.681Z","comments":true,"path":"2019-05-07-leetcode-best-time-to-buy-and-sell-stock-series/","link":"","permalink":"https://paaatrick.com/2019-05-07-leetcode-best-time-to-buy-and-sell-stock-series/","excerpt":"有关买卖股票最佳时机系列做题笔记，Python实现 122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock IILeetCodeCN 第122题链接 第一种方法：深度优先搜索，时间复杂度O(2^n)","text":"有关买卖股票最佳时机系列做题笔记，Python实现 122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock IILeetCodeCN 第122题链接 第一种方法：深度优先搜索，时间复杂度O(2^n) 第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n) 1234567class Solution: def maxProfit(self, prices: List[int]) -&gt; int: ans = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: ans += prices[i] - prices[i-1] return ans","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—递归、分治相关题目","slug":"leetcode-recursion-divide-conquer","date":"2019-05-07T02:45:27.000Z","updated":"2019-05-07T09:04:46.164Z","comments":true,"path":"2019-05-07-leetcode-recursion-divide-conquer/","link":"","permalink":"https://paaatrick.com/2019-05-07-leetcode-recursion-divide-conquer/","excerpt":"有关递归与分治的做题笔记，Python实现 50. Pow(x, n)LeetCodeCN 第50题链接 第一种方法：递归 123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n - 1) return self.myPow(x * x, n / 2) 第二种方法：循环","text":"有关递归与分治的做题笔记，Python实现 50. Pow(x, n)LeetCodeCN 第50题链接 第一种方法：递归 123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n - 1) return self.myPow(x * x, n / 2) 第二种方法：循环 1234567891011121314class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x = 1 / x n = -n ans = 1 while n: # n&amp;1 是与运算，用来求奇偶，效果与 n%2 一样 if n &amp; 1: ans *= x x = x * x # n&gt;&gt;=1 是位运算，右移一位，效果与 n//=2 一样 n &gt;&gt;= 1 return ans 169. 求众数 Majority ElementLeetCodeCN 第169题链接 第一种方法：两重循环暴力求解 第二种方法：哈希表记录每个元素出现次数，发现出现超过n/2的就是众数 12345678910111213class Solution: def majorityElement(self, nums: List[int]) -&gt; int: leng = len(nums) if leng == 1: return nums[0] dic = &#123;&#125; for i in nums: if i in dic: dic[i] += 1 if dic[i] &gt;= leng / 2: return i else: dic[i] = 1 第三种方法：排序后直接返回中间值，因为题目限定条件必然存在众数 12def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2] 第四种方法：用list.count()方法 12345def majorityElement(self, nums: List[int]) -&gt; int: # 此处如果遍历整个nums会超时 for i in nums[len(nums)//2:]: if nums.count(i) &gt; len(nums)//2: return i 第五种方法：分治 123456789101112131415161718def majorityElement(self, nums): if not nums: return None if len(nums) == 1: return nums[0] a = self.majorityElement(nums[:len(nums)//2]) b = self.majorityElement(nums[len(nums)//2:]) if a == b: return a return [b, a][nums.count(a) &gt; len(nums)//2] # 这个 return 的写法等同于下面的 if else # 因为若后一个[]里为True即1所以取[b,a][1]=a, False即0取[b,a][0]=b # # if nums.count(a) &gt; len(nums)//2: # return a # else: # return b","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—二叉树相关题目","slug":"leetcode-tree","date":"2019-05-04T06:29:10.000Z","updated":"2019-05-07T09:04:27.071Z","comments":true,"path":"2019-05-04-leetcode-tree/","link":"","permalink":"https://paaatrick.com/2019-05-04-leetcode-tree/","excerpt":"有关二叉树的做题笔记，Python实现 二叉树的定义123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 98. 验证二叉搜索树 Validate Binary Search TreeLeetCodeCN 第98题链接 第一种方法：中序遍历二叉树存入数组，与直接升序排序去重后的原二叉树对比","text":"有关二叉树的做题笔记，Python实现 二叉树的定义123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 98. 验证二叉搜索树 Validate Binary Search TreeLeetCodeCN 第98题链接 第一种方法：中序遍历二叉树存入数组，与直接升序排序去重后的原二叉树对比 123456789class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: inorder = self.inorder(root) return inorder == list(sorted(set(inorder))) def inorder(self, root) -&gt; list: if root is None: return [] return self.inorder(root.left) + [root.val] + self.inorder(root.right) 第二种方法：中序遍历只用比较前一节点的值是否小于当前节点的值即可，不用储存 1234567891011121314class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: self.prev = None return self.helper(root) def helper(self, root): if root is None: return True if not self.helper(root.left): return False if self.prev and self.prev.val &gt;= root.val: return False self.prev = root return self.helper(root.right) 第三种方法：递归验证每个节点左孩子的值是否小于父亲节点的值以及右孩子的值是否大于父亲节点的值 1234567891011class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: mini, maxi = float('-inf'), float('inf') return self.isValid(root, mini, maxi) def isValid(self, root: TreeNode, mini: int, maxi: int) -&gt; bool: if root is None: return True if mini &gt;= root.val or maxi &lt;= root.val: return False return self.isValid(root.left, mini, root.val) and self.isValid(root.right, root.val, maxi) 236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary TreeLeetCodeCN 第236题链接 首先如果root为空，返回root，然后如果root就是p或者q，那root就是最近公共祖先。然后分别对左子树和右子树做递归并保存结果，如果两边都能找到，证明本节点就是最近公共祖先，如果一边找得到，一边找不到，则往能找到的那边继续找下去。 1234567891011121314151617class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root is None: return None if root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left or right: if left is None: return right elif right is None: return left else: return root else: return None 235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search TreeLeetCodeCN 第235题链接 第一种方法：还用上面的方法 第二种方法：利用二叉搜索树的左子树都小于父亲节点，右子树都大于父亲节点的特性，可以把第一种方法简化一下 1234567class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if p.val &lt; root.val and q.val &lt; root.val: return self.lowestCommonAncestor(root.left, p, q) if p.val &gt; root.val and q.val &gt; root.val: return self.lowestCommonAncestor(root.right, p, q) return root 第三种方法：跟方法二的思路一样，把递归改成循环 12345678def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': while root: if p.val &lt; root.val and q.val &lt; root.val: root = root.left elif p.val &gt; root.val and q.val &gt; root.val: root = root.right else: return root","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—哈希表相关题目","slug":"leetcode-hashtable","date":"2019-05-01T07:18:53.000Z","updated":"2019-05-07T09:02:49.943Z","comments":true,"path":"2019-05-01-leetcode-hashtable/","link":"","permalink":"https://paaatrick.com/2019-05-01-leetcode-hashtable/","excerpt":"有关哈希表的做题笔记，Python实现 242. 有效的字母异位词 Valid AnagramLeetCodeCN 第242题链接 第一种方法：对两个字符串排序后对比 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return sorted(s) == sorted(t) 第二种方法：用哈希表对字符串内每个字符计数，最后比对哈希表，这里用dict实现","text":"有关哈希表的做题笔记，Python实现 242. 有效的字母异位词 Valid AnagramLeetCodeCN 第242题链接 第一种方法：对两个字符串排序后对比 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return sorted(s) == sorted(t) 第二种方法：用哈希表对字符串内每个字符计数，最后比对哈希表，这里用dict实现 12345678class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: map1, map2 = &#123;&#125;, &#123;&#125; for i in s: map1[i] = map1.get(i, 0) + 1 for j in t: map2[j] = map2.get(j, 0) + 1 return map1 == map2 1. 两数之和 Two SumLeetCodeCN 第1题链接 第一种方法：用哈希表，时间复杂度是O(n) 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = &#123;&#125; for i in range(len(nums)): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 第二种方法：暴力两重遍历，这样时间复杂度是O(n^2)，在LeetCode里提交会超时123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i, j] 15. 三数之和 3SumLeetCodeCN 第15题链接 第一种方法：三重遍历，时间复杂度为O(n^3) 第二种方法：两重遍历得到前两个数，然后查询第三个数-(a+b)是否存在。用哈希表set() 1234567891011121314151617181920class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" if len(nums) &lt; 3: return [] nums.sort() res = set() for i, v in enumerate(nums[:-2]) : if i &gt;= 1 and v == nums[i-1]: continue d = &#123;&#125; for x in nums[i+1:]: if x not in d: d[-(v+x)] = 1 else: res.add((v, -(v+x), x)) return map(list, res) 第三种方法：先升序排序，一遍遍历，然后在后面的新数组里用双指针检查三个数之和是否为0，大于0则右指针向左走，小于0则左指针向右走。 12345678910111213141516171819202122232425class Solution(object): def threeSum(self, nums): if len(nums) &lt; 3: return [] nums.sort() res = [] for i, x in enumerate(nums[:-2]): if i &gt;= 1 and x == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l += 1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—栈、堆、队列相关题目","slug":"leetcode-stack-heap-queue","date":"2019-04-29T05:32:28.000Z","updated":"2019-05-07T09:02:49.943Z","comments":true,"path":"2019-04-29-leetcode-stack-heap-queue/","link":"","permalink":"https://paaatrick.com/2019-04-29-leetcode-stack-heap-queue/","excerpt":"有关栈、堆、队列的做题笔记，Python实现 20. 有效的括号 Valid ParenthesesLeetCodeCN 第20题链接 使用 Stack 栈 来操作，用了一个技巧是先做一个字典，key为右括号，value为左括号。","text":"有关栈、堆、队列的做题笔记，Python实现 20. 有效的括号 Valid ParenthesesLeetCodeCN 第20题链接 使用 Stack 栈 来操作，用了一个技巧是先做一个字典，key为右括号，value为左括号。 12345678910class Solution: def isValid(self, s: str) -&gt; bool: stack = [] mapping = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; for c in s: if c not in mapping: stack.append(c) elif not stack or mapping[c] != stack.pop(): return False return not stack 703. 数据流中的第K大元素 Kth Largest Element in a StreamLeetCodeCN 第703题链接 方法一：直接降序排序，然后取第k个元素返回，add时每次都再排序一次，这样时间复杂度为O(k*logk) 123456789101112131415# 1.直接排序class KthLargest: def __init__(self, k: int, nums: List[int]): self.nums = nums self.k = k self.nums.sort(reverse = True) while len(self.nums) &gt; k: self.nums.pop() def add(self, val: int) -&gt; int: self.nums.append(val) self.nums.sort(reverse = True) if len(self.nums) &gt; self.k: self.nums.pop() return self.nums[-1] 方法二：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，时间复杂度降低为O(k) 1234567891011121314151617181920# 2.小顶堆import heapqclass KthLargest: def __init__(self, k: int, nums: List[int]): self.pool = nums heapq.heapify(self.pool) self.k = k while len(self.pool) &gt; k: heapq.heappop(self.pool) def add(self, val: int) -&gt; int: if len(self.pool) &lt; self.k: heapq.heappush(self.pool, val) elif val &gt; self.pool[0]: heapq.heapreplace(self.pool, val) return self.pool[0]# Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 239. 滑动窗口最大值 Sliding Window MaximumLeetCodeCN 第239题链接 第一种方法：用优先队列：大顶堆 第二种方法：因为窗口大小固定，只需要一个双端队列即可 1234567891011121314class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] window, res = [], [] for i, x in enumerate(nums): if i &gt;= k and window[0] &lt;= i - k: window.pop(0) while window and nums[window[-1]] &lt;= x: window.pop() window.append(i) if i &gt;= k - 1: res.append(nums[window[0]]) return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记--链表相关题目","slug":"leetcode-linklist","date":"2019-04-28T08:52:35.000Z","updated":"2019-05-07T09:02:49.942Z","comments":true,"path":"2019-04-28-leetcode-linklist/","link":"","permalink":"https://paaatrick.com/2019-04-28-leetcode-linklist/","excerpt":"有关链表的做题笔记，Python实现 链表定义12345# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = None 206. 反转链表 Reverse Linked ListLeetCodeCN 第206题链接 遍历链表，迭代前节点prev，缓存当前节点current的下一节点，然后把当前节点的next指针指向前节点prev","text":"有关链表的做题笔记，Python实现 链表定义12345# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = None 206. 反转链表 Reverse Linked ListLeetCodeCN 第206题链接 遍历链表，迭代前节点prev，缓存当前节点current的下一节点，然后把当前节点的next指针指向前节点prev 12345678910class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: current = head prev = None while current: tmp = current.next current.next = prev prev = current current = tmp return prev 用Python三元交换能同时赋值不需要缓存的特性可以一行完成交换 1234567class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: current = head prev = None while current: current.next, prev, current = prev, current, current.next return prev 24. 两两交换链表中的节点 Swap Nodes in PairsLeetCodeCN 第24题链接 记录当前节点的前一个节点，当当前节点和下一节点都存在时，三元交换三个节点的next指针返回交换完后的首节点（这里不太明白为什么self的取值是ListNode(None)） 看到好多小伙伴在问，我来尝试解释一下“链表交换相邻元素”中 self 是怎么回事。1.首先看到最后 return self.next ，可以看到作者是想把 self 当做链表的头指针使用的（注意：头指针 pHead 与传入的参数 head 是不同的，head 是第一个结点，而 pHead.next == next ）。用头指针有什么好处呢？因为我们让头指针的 next 域（pHead.next）永远指向第一个结点，就是避免最后返回的时候找不到第一个结点了。2.那么作者为什么可以 pre, pre.next = self, head 这样写呢？因为 self 是这个类的一个对象，所以在类定义的时候可以在任何地方，给 self 增加新的属性。相信大家都知道在 init(self, attr) 里面可以定义通过 self.myattr = attr 来定义一个 myattr 属性。其实这个语句写在任意一个类的方法里都可以，所以在原文 swapPairs() 里面当然也可以定义新的属性。所以这行代码应该理解为，pre 指向 self（虽然 self 不是一个 ListNode 类型的对象，但它只要有一个 next 就可以了），同时为 pre（同时也是为 self，它们是一样的现在）增加一个 next 属性，这个 next 属性指向第一个结点 head。3.明白上面之后，这里就好办了。在第一次 while 循环的时候，pre.next 被赋值为 b（也就是原来第二个结点，转换为变成了第一个，也就成为了新链表的第一个结点。如果原来是[1,2,3,4]，那么现在就是[2,1,3,4]，这个 self.next 就是指向 2 这个结点）。所以最后只要返回 self.next 就得到了答案。其实换个写法大家就好理解很多了：pHead = ListNode(None)pre, pre.next = pHead, head也就是说不用 self 也可以，只是原作者秀了一把小技巧而已。 123456789class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: pre, pre.next = self, head while pre.next and pre.next.next: l = pre.next r = l.next pre.next, l.next, r.next = r, r.next, l pre = l return self.next 141. 环形链表 Linked List CycleLeetCodeCN 第141题链接 三种方法1.硬做，可以设置超时或者固定循环次数，不靠谱2.做记号，使用set来储存遍历过的节点，需要额外内存空间3.快慢指针，慢指针每次前移一个节点，快指针每次前移两个节点，如果链表存在循环那快慢指针肯定会相遇 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): # 1.硬做 def hasCycle1(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return False curr = head for i in range(100000): curr = curr.next if not curr: return False return True # 2.set记录 def hasCycle2(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" rec = set() curr = head while curr: if curr in rec: return True rec.add(curr) curr = curr.next return False # 3.快慢指针 def hasCycle3(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" slow = fast = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 142. 环形链表 II Linked List Cycle IILeetCodeCN 第142题链接 第一种方法还是上面的用哈希表set来记录，占用空间 123456789101112131415class Solution(object): # 1.set记录 def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" rec = [] curr = head while curr: if curr in rec: return rec[rec.index(curr)] rec.append(curr) curr = curr.next return None 第二种方法用快慢指针，先如上题一样检测是否有环，有的话设置一个新的检测节点从头(head)开始迭代，同时slow节点也继续迭代，直到二者相遇的点就是环的入口节点。 原理：首先，头结点到入环结点的距离为a，入环结点到相遇结点的距离为b，相遇结点到入环结点的距离为c。然后，当f以s的两倍速度前进并和s相遇时，f走过的距离是s的两倍，即有等式：a+b+c+b = 2(a+b) ，可以得出 a = c ，所以说，让fast和slow分别从相遇结点和头结点同时同步长出发，他们的相遇结点就是入环结点。当快、慢指针同时从入环点出发，那么一定会在入环点相遇。如果快、慢指针同时从入环点前一节点出发，那么快慢、指针则会在入环点的前一节点相遇，以此类推。 123456789101112131415161718class Solution(object): # 2.快慢指针 def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = fast = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: detection = head while slow != detection: slow = slow.next detection = detection.next return detection return None 25. k个一组翻转链表 Reverse Nodes in k-GroupLeetCodeCN 第25题链接 利用数组来实现k个一组的翻转，然后重新连接成链表12345678910111213141516class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: arr, i = [], 0 if not head: return None while head: arr.append(head) head = head.next while i &lt;= len(arr) - k: arr[i:i+k] = arr[i:i+k][::-1] i += k for j in range(len(arr) - 1): arr[j].next = arr[j+1] if arr: arr[-1].next = None return arr[0]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"关于 NSUserDefaults setBool 的值取出后if判断不了的问题","slug":"nsuserdefaults-setbool-forkey","date":"2019-04-23T03:30:27.000Z","updated":"2019-05-07T09:02:49.942Z","comments":true,"path":"2019-04-23-nsuserdefaults-setbool-forkey/","link":"","permalink":"https://paaatrick.com/2019-04-23-nsuserdefaults-setbool-forkey/","excerpt":"","text":"使用 [[NSUserDefaults standardUserDefaults] setBool:(BOOL)value forKey:(NSString *)defaultName] 设置的值，如果用普通的objectForKey:取出的值是__NSCFBoolean类型，if语句无法判断，即使后加== YES也没用，还会出问题。 要用 [[NSUserDefaults standardUserDefaults] boolForKey:(NSString *)defaultName] 来取值， 同理：12345- (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName;- (void)setFloat:(float)value forKey:(NSString *)defaultName;- (void)setDouble:(double)value forKey:(NSString *)defaultName;- (void)setBool:(BOOL)value forKey:(NSString *)defaultName;- (void)setURL:(nullable NSURL *)url forKey:(NSString *)defaultName; 如上所示等入值方法，都用对应配套的取值方法12345- (NSInteger)integerForKey:(NSString *)defaultName;- (float)floatForKey:(NSString *)defaultName;- (double)doubleForKey:(NSString *)defaultName;- (BOOL)boolForKey:(NSString *)defaultName;- (nullable NSURL *)URLForKey:(NSString *)defaultName;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS集成支付宝H5支付实现跳转与回调的解决方案","slug":"ios-alipay-h5-solution","date":"2019-03-22T12:28:36.000Z","updated":"2019-05-07T09:02:49.940Z","comments":true,"path":"2019-03-22-ios-alipay-h5-solution/","link":"","permalink":"https://paaatrick.com/2019-03-22-ios-alipay-h5-solution/","excerpt":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇： iOS集成H5微信支付实现跳转与回调的解决方案 实现的效果是：App→支付宝→支付(成功失败或取消)→App","text":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇： iOS集成H5微信支付实现跳转与回调的解决方案 实现的效果是：App→支付宝→支付(成功失败或取消)→App 前置准备本项目使用WKWebView，前置动作是后端小伙伴已经处理好支付宝H5支付下单链接，客户端接收到下单链接后的操作。 下单链接即为支付宝H5支付文档-参数说明-公共参数中构造的https://openapi.alipay.com/gateway.do开头的的链接，构造链接的操作交由后端处理。 操作步骤1. 添加 URL Scheme 并把支付宝加入白名单 添加 URL Scheme。在 xcodeproj 文件 Info 选项卡最下面的 URL Types内设置。 该 URL Scheme 不像微信支付因为要校验必须设置商户后台填的一级域名，支付宝的这个可以任意设置。 把支付宝的 URL Scheme alipay 和 alipays 填入项目的白名单。在 xcodeproj 文件 Info 选项卡内的 Custom iOS Target Properties 的 LSApplicationQueriesSchemes 里添加上述两个字符串，若没有 LSApplicationQueriesSchemes 就手动输入添加，类型为数组 Array。 2. WKWebView加载链接添加协议 WKNavigationDelegate和WKUIDelegate。 创建一个WKWebView，并加载统一下单链接。 123456789- (void)buildWKWebView &#123; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)]; [self.view addSubview:webView]; webView.navigationDelegate = self; webView.UIDelegate = self; NSURL *payURL = [NSURL URLWithString:self.payString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:payURL]; [webView loadRequest:request];&#125; 此处self.payString就是后台传来的支付宝5支付统一下单链接，格式为： https://openapi.alipay.com/gateway.do?app_id=2015081808011180&amp;biz_content={&quot;body&quot;%3A&quot;支付宝充值&quot;%2C&quot;subject&quot;%3A&quot;10000宝石&quot;%2C&quot;out_trade_no&quot;%3A&quot;30677&quot;%2C&quot;total_amount&quot;%3A&quot;1.00&quot;%2C&quot;seller_id&quot;%3A&quot;2088721584425035&quot;%2C&quot;product_code&quot;%3A&quot;QUICK_WAP_PAY&quot;%2C&quot;goods_type&quot;%3A&quot;1&quot;%2C&quot;passback_params&quot;%3A&quot;20190322083556lkkzmwT2wi0bAaFL1W&quot;%2C&quot;store_id&quot;%3A&quot;company&quot;%2C&quot;timeout_express&quot;%3A&quot;3m&quot;}&amp;charset=UTF-8&amp;format=JSON&amp;method=alipay.trade.wap.pay&amp;notify_url=https%3A%2F%2Fsttv3-api.company.com%2FaliNotify&amp;return_url=https%3A%2F%2Fwww.company.com&amp;sign_type=RSA2&amp;timestamp=2019-03-22+20%3A35%3A56&amp;version=1.0&amp;sign=rmnKUOsZBYi%2BWzDELY%2B5ixnSFn0b0S38K0NR45SRZBAvmzr0qaXm7mnKaXm7OrvmnKUOsZRYiaJ2LNAaFL1K0hvJ3L3hZqH5HifNCIJ0hfTr1OkA5Lgyn1SCx74SrSWVfXdMXqiLurpN0Mj%2B2zs7vDee%2B8vxwzhRG3a5EaZbOHDQFN1%2OrvvVcdv%2F%2FBJCwISBhoXhBelvfZRYiaJ2LNAaFL1KdrJvjlo2lR%2BEzvda0ppMKFzjMLxRZBAvmzr0qNwxyTMfAuxjAT2%2BXAaF3hZqH5Hlo2lRiaJ2LNE 不像微信支付还要加个请求头，支付宝的简单的多，直接访问即可。 3. 实现代理方法拦截链接并跳转支付宝12345678910111213141516171819202122232425262728- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if ([navigationAction.request.URL.scheme isEqualToString:@\"alipay\"]) &#123; // 1.以？号来切割字符串 NSArray *urlBaseArr = [navigationAction.request.URL.absoluteString componentsSeparatedByString:@\"?\"]; NSString *urlBaseStr = urlBaseArr.firstObject; NSString *urlNeedDecode = urlBaseArr.lastObject; // 2.将截取以后的Str，做一下URLDecode，方便我们处理数据 NSMutableString *afterDecodeStr = [NSMutableString stringWithString:[SmallTools decoderUrlEncodeStr:urlNeedDecode]]; // 3.替换里面的默认Scheme为自己的Scheme NSString *afterHandleStr = [afterDecodeStr stringByReplacingOccurrencesOfString:@\"alipays\" withString:@\"alipayreturn.company.com\"]; // 4.然后把处理后的，和最开始切割的做下拼接，就得到了最终的字符串 NSString *finalStr = [NSString stringWithFormat:@\"%@?%@\",urlBaseStr, [SmallTools urlEncodeStr:afterHandleStr]]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 判断一下，是否安装了支付宝APP（也就是看看能不能打开这个URL） if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:finalStr]]) &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:finalStr]]; &#125; else &#123; //未安装支付宝, 自行处理 &#125; &#125;); decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; 顺便附带一下 URL 的 Encode 和 Decode 方法。 12345678910111213//urlEncode编码+ (NSString *)urlEncodeStr:(NSString *)input &#123; NSString *charactersToEscape = @\"?!@#$^&amp;%*+,:;='\\\"`&lt;&gt;()[]&#123;&#125;/\\\\| \"; NSCharacterSet *allowedCharacters = [[NSCharacterSet characterSetWithCharactersInString:charactersToEscape] invertedSet]; NSString *upSign = [input stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters]; return upSign;&#125;//urlEncode解码+ (NSString *)decoderUrlEncodeStr: (NSString *) input &#123; NSMutableString *outputStr = [NSMutableString stringWithString:input]; [outputStr replaceOccurrencesOfString:@\"+\" withString:@\"\" options:NSLiteralSearch range:NSMakeRange(0,[outputStr length])]; return [outputStr stringByRemovingPercentEncoding];&#125; 4. AppDelegate 中接收跳转动作当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。 以下是AppDelegate接收返回动作的示例。 其中支付宝回调的 host 是固定的 safepay，而微信支付的 host 随意定义。 123456789101112131415- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; //safepay是支付宝H5支付的回调host, if ([url.host isEqualToString:@\"wxpaycallback\"] || [url.host isEqualToString:@\"safepay\"]) &#123; // 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等 UITabBarController *tabBarVC = (UITabBarController *)topRootViewController; UINavigationController *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex]; [navVC popViewControllerAnimated:YES]; NSString *orderId = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayOrderId\"]; NSString *payFee = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayFee\"]; //以及更多参数 NSDictionary *resultDict = @&#123;@\"order_id\":orderId, @\"payFee\":payFee&#125;; [[NSNotificationCenter defaultCenter] postNotificationName:@\"htmlPaymentNotification\" object:self userInfo:resultDict]; &#125;&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS集成H5微信支付实现跳转与回调的解决方案","slug":"ios-wxpay-h5-solution","date":"2019-03-22T10:12:20.000Z","updated":"2019-05-07T09:02:49.941Z","comments":true,"path":"2019-03-22-ios-wxpay-h5-solution/","link":"","permalink":"https://paaatrick.com/2019-03-22-ios-wxpay-h5-solution/","excerpt":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： iOS集成支付宝H5支付实现跳转与回调的解决方案 实现的效果是：App→微信→支付(成功失败或取消)→App","text":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： iOS集成支付宝H5支付实现跳转与回调的解决方案 实现的效果是：App→微信→支付(成功失败或取消)→App 前置准备本项目使用WKWebView，前置动作是后端小伙伴已经处理好微信H5支付下单链接，客户端接收到下单链接后的操作。 下单链接即为微信支付文档-统一下单API中返回的 mweb_url，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241。 操作步骤1. 添加 URL Scheme 并把微信加入白名单 添加 URL Scheme。在 xcodeproj 文件 Info 选项卡最下面的 URL Types内设置。 注意此URL的一级域名需要与微信商户后台(微信商户平台-产品中心-开发配置-H5支付)设置的的一级域名一致，比如微信商户里设置的是company.com，那 URL Schemes 可以设为 a1.company.com，此特性使得一套H5支付可以方便得集成到多个App。只有一个App需要H5支付的话也可以直接填与微信后台的一致的 company.com 。 2019年4月10日更新如果像上图那样填的是 www.company.com，那 URL Scheme 只能设为其三级域名如 a2.www.company.com 或同样的 www.company.com 把微信的 URL Scheme weixin 和 wechat 填入项目的白名单。在 xcodeproj 文件 Info 选项卡内的 Custom iOS Target Properties 的 LSApplicationQueriesSchemes 里添加上述两个字符串，若没有 LSApplicationQueriesSchemes 就手动输入添加，类型为数组 Array。 2. WKWebView加载链接添加协议 WKNavigationDelegate和WKUIDelegate。 创建一个WKWebView，并加载统一下单链接。 12345678910- (void)buildWKWebView &#123; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)]; [self.view addSubview:webView]; webView.navigationDelegate = self; webView.UIDelegate = self; NSURL *payURL = [NSURL URLWithString:self.payString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:payURL]; [request setValue:@\"a1.company.com://wxpaycallback/\" forHTTPHeaderField:@\"Referer\"]; [webView loadRequest:request];&#125; 此处self.payString就是后台传来的微信H5支付统一下单链接，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458041。 我们需要做的处理是根据文档给这个请求添加请求头 Referer，关键在于这个 a1.company.com://wxpaycallback/ 既满足了微信检测到有商户后台设置好的一级域名，同时把这个链接做成了 URL Scheme 使得可以在跳转微信客户端后（不管支付成功还是失败）能顺利跳转回自己的App。其中的 host wxpaycallback/ 可以任意设置，方便在 AppDelegate 里处理跳转回来后部署业务逻辑。当然如果你不需要在 AppDelegate 里接收动作而是直接跳回支付界面自行后续处理的话就只用设为前一步在 URL Scheme a1.company.com:// 即可。 2019.4.10 更新 经过测试，对于App内的H5支付而言，实际上是下面步骤里@&quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb&quot;后接的参数 redirect_url 对支付后跳回App起作用，Referer只起到给微信校验的作用。 所以 Referer 只需要设置成微信H5支付登记的域名的子域名即可，如[request setValue:@&quot;a1.company.com&quot; forHTTPHeaderField:@&quot;Referer&quot;]; 3. 实现代理方法拦截链接并跳转微信1234567891011121314151617181920212223242526272829303132333435363738- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURLRequest *request = navigationAction.request; NSString *absoluteString = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding]; // 拦截WKWebView加载的微信支付统一下单链接, 将redirect_url参数修改为唤起自己App的URLScheme if ([absoluteString hasPrefix:@\"https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb\"] &amp;&amp; ![absoluteString hasSuffix:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]) &#123; decisionHandler(WKNavigationActionPolicyCancel); NSString *redirectUrl = nil; if ([absoluteString containsString:@\"redirect_url=\"]) &#123; NSRange redirectRange = [absoluteString rangeOfString:@\"redirect_url\"]; redirectUrl = [[absoluteString substringToIndex:redirectRange.location] stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; else &#123; redirectUrl = [absoluteString stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; NSMutableURLRequest *newRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:redirectUrl] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; newRequest.allHTTPHeaderFields = request.allHTTPHeaderFields; newRequest.URL = [NSURL URLWithString:redirectUrl]; [webView loadRequest:newRequest]; return; &#125; //拦截重定向的跳转微信的 URL Scheme, 打开微信 if ([absoluteString hasPrefix:@\"weixin://\"]) &#123; decisionHandler(WKNavigationActionPolicyAllow); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if ([[UIApplication sharedApplication] canOpenURL:navigationAction.request.URL]) &#123; [[UIApplication sharedApplication] openURL:navigationAction.request.URL]; &#125; else &#123; //未安装微信, 自行处理 &#125; &#125;); return; &#125; decisionHandler(WKNavigationActionPolicyAllow); return;&#125; 4. AppDelegate 中接收跳转动作当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。 以下是AppDelegate接收返回动作的示例。 123456789101112131415- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; //safepay是支付宝H5支付的回调host if ([url.host isEqualToString:@\"wxpaycallback\"] || [url.host isEqualToString:@\"safepay\"]) &#123; // 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等 UITabBarController *tabBarVC = (UITabBarController *)topRootViewController; UINavigationController *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex]; [navVC popViewControllerAnimated:YES]; NSString *orderId = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayOrderId\"]; NSString *payFee = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayFee\"]; //以及更多参数 NSDictionary *resultDict = @&#123;@\"order_id\":orderId, @\"payFee\":payFee&#125;; [[NSNotificationCenter defaultCenter] postNotificationName:@\"htmlPaymentNotification\" object:self userInfo:resultDict]; &#125;&#125; 5. 关于微信H5支付域名设置 2019年4月10日更新 这里额外提一下，截止到2019年4月，微信支付设置页面明确说了 添加域名后，其所属的子域名将都有权限 也就是说只需要填一个一级域名比如 company.com ，就可以有无限多个二级域名可供不同App使用，绕过微信H5支付只能添加5个域名的限制。如果填的是二级域名比如 www.company.com，那么只能往下使用三级域名比如 a1.www.company.com 以微信H5支付域名填了 company.com 为例，那可以这样操作 App Alpha Beta-A1 Beta-A2 Gamma 添加的Referer alpha.company.com a1.beta.company.com a2.beta.company.com gamma.company.com 要替换的redirect_url alpha.company.com://optional a1.beta.company.com:// a2.beta.company.com://optional gamma.company.com:// URL Scheme alpha.company.com a1.beta.company.com a2.beta.company.com gamma.company.com 参考博客链接","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"判断一个 NSArray 是否为空","slug":"if-nsarray-null","date":"2019-03-12T07:34:27.000Z","updated":"2019-05-07T09:02:49.940Z","comments":true,"path":"2019-03-12-if-nsarray-null/","link":"","permalink":"https://paaatrick.com/2019-03-12-if-nsarray-null/","excerpt":"","text":"1234if ([array isKindOfClass:[NSArray class]] &amp;&amp; array.count &gt; 0)&#123; NSLog(@\"这是一个非空数组\");&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iPhone屏幕各种尺寸分辨率（更新至XS）","slug":"iphone-pixel-point-size-scale","date":"2019-03-05T07:57:28.000Z","updated":"2019-05-07T09:02:49.939Z","comments":true,"path":"2019-03-05-iphone-pixel-point-size-scale/","link":"","permalink":"https://paaatrick.com/2019-03-05-iphone-pixel-point-size-scale/","excerpt":"","text":"Device Logic Point Logic Pixel Size Scale iPhone 2G 480 × 320 480 × 320 3.5 1x iPhone 3 480 × 320 480 × 320 3.5 1x iPhone 3GS 480 × 320 480 × 320 3.5 1x iPhone 4 480 × 320 960 × 640 3.5 2x iPhone 4S 480 × 320 960 × 640 3.5 2x iPhone 5 568 × 320 1136 × 640 4.0 2x iPhone 5S 568 × 320 1136 × 640 4.0 2x iPhone 5C 568 × 320 1136 × 640 4.0 2x iPhone 6 667 × 375 1334 × 750 4.7 2x iPhone 6 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 6S 667 × 375 1334 × 750 4.7 2x iPhone 6S Plus 736 × 414 2208 × 1242 5.5 3x iPhone SE 568 × 320 1136 × 640 4.0 2x iPhone 7 667 × 375 1334 × 750 4.7 2x iPhone 7 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 8 667 × 375 1334 × 750 4.7 2x iPhone 8 Plus 736 × 414 2208 × 1242 5.5 3x iPhone X 812 × 375 2436 × 1125 5.8 3x iPhone XS 812 × 375 2436 × 1125 5.8 3x iPhone XR 896 × 414 1792 × 828 6.1 2x iPhone XS Max 896 × 414 2688 × 1242 6.5 3x","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS处理多线程异步Block中的UI操作","slug":"ios-block-and-mainqueue","date":"2019-02-23T04:05:28.000Z","updated":"2019-05-07T09:02:49.939Z","comments":true,"path":"2019-02-23-ios-block-and-mainqueue/","link":"","permalink":"https://paaatrick.com/2019-02-23-ios-block-and-mainqueue/","excerpt":"","text":"多线程方法的completionHandlerblock可能运行在非主线程上。两种处理方法： 在block里手动加上dispatch_async(dispatch_get_main_queue(), ^{}); 123456789101112NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];//no delegateQueueNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123;/* do UI things */&#125;); //or [self performSelectorOnMainThread:@selector(doUIthings) withObject:nil waitUntilDone:NO];&#125;];[task resume]; 带有delegateQueue等参数的方法，可传入主线程队列，然后blockcompletionHandler便运行在主线程了。 12345678910NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue mainQueue]];//get the mainQueueNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;/* do UI things */&#125;];[task resume];","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS 判断NSString值是否为空或null并转换为空字符串","slug":"transfer-null-to-nsstring","date":"2019-02-12T09:52:26.000Z","updated":"2019-05-07T09:02:49.938Z","comments":true,"path":"2019-02-12-transfer-null-to-nsstring/","link":"","permalink":"https://paaatrick.com/2019-02-12-transfer-null-to-nsstring/","excerpt":"","text":"遇到了一个后台json误将null作为字符串值导致iOS客户端崩溃闪退的问题，解决方法如下：套一层判断，如果是各种情况的null则转换为@””。 1234567+ (NSString *) nullToString:(id)string &#123; if ([string isEqual:@\"NULL\"] || [string isKindOfClass:[NSNull class]] || [string isEqual:[NSNull null]] || [string isEqual:NULL] || [[string class] isSubclassOfClass:[NSNull class]] || string == nil || string == NULL || [string isKindOfClass:[NSNull class]] || [[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] length]==0 || [string isEqualToString:@\"&lt;null&gt;\"] || [string isEqualToString:@\"(null)\"]) &#123; return @\"\"; &#125; else &#123; return (NSString *)string; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS MJExtension使用方法指南(Objective-C)","slug":"mj-extension-guide","date":"2019-02-03T07:29:04.000Z","updated":"2019-05-07T09:02:49.938Z","comments":true,"path":"2019-02-03-mj-extension-guide/","link":"","permalink":"https://paaatrick.com/2019-02-03-mj-extension-guide/","excerpt":"","text":"MJExtension能做什么？1. MJExtension是一套字典和模型之间互相转换的超轻量级框架2. MJExtension能完成的功能1234字典（JSON） --&gt; 模型（Model）模型（Model） --&gt; 字典（JSON）字典数组（JSON Array） --&gt; 模型数组（Model Array）模型数组（Model Array） --&gt; 字典数组（JSON Array） 详尽用法主要参考 main.m中的各个函数 以及 NSObject+MJKeyValue.h MJExtension和JSONModel、Mantle等框架的区别1. 转换速率：最近一次测试表明：MJExtension &gt; JSONModel &gt; Mantle 各位开发者也可以自行测试 2. 具体用法：1234567891011JSONModel：要求所有模型类必须继承自JSONModel基类Mantle：要求所有模型类必须继承自MTModel基类MJExtension：不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 如何安装MJExtension方法一：cocoapods导入： 1pod 'MJExtension' 方法二：手动导入： 1234567891011121314151617将MJExtensionExample/MJExtensionExample/MJExtension文件夹中的所有源代码拽入项目中导入主头文件：#import \"MJExtension.h\"MJExtension.hMJConst.hMJConst.mMJFoundation.hMJFoundation.mMJIvar.hMJIvar.mMJType.hMJType.mNSObject+MJCoding.hNSObject+MJCoding.mNSObject+MJIvar.hNSObject+MJIvar.mNSObject+MJKeyValue.hNSObject+MJKeyValue.m 如何使用MJExtension1. 最简单的字典转模型12345678910111213141516171819202122232425typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;@property (copy, nonatomic) NSString *icon;@property (assign, nonatomic) int age;@property (assign, nonatomic) double height;@property (strong, nonatomic) NSNumber *money;@property (assign, nonatomic) Sex sex;@endNSDictionary *dict = @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", @\"age\" : @20, @\"height\" : @\"1.55\", @\"money\" : @100.9, @\"sex\" : @(SexFemale) &#125;;// 将字典转为User模型User *user = [User objectWithKeyValues:dict];NSLog(@\"name=%@, icon=%@, age=%d, height=%@, money=%@, sex=%d\", user.name, user.icon, user.age, user.height, user.money, user.sex);// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1 核心代码1：1[User objectWithKeyValues:dict] 2. 模型中嵌套模型12345678910111213141516171819202122232425262728293031323334353637@interface Status : NSObject/** 微博文本内容 */@property (copy, nonatomic) NSString *text;/** 微博作者 */@property (strong, nonatomic) User *user;/** 转发的微博 */@property (strong, nonatomic) Status *retweetedStatus;@endNSDictionary *dict = @&#123; @\"text\" : @\"是啊，今天天气确实不错！\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125;, @\"retweetedStatus\" : @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125; &#125;;// 将字典转为Status模型Status *status = [Status objectWithKeyValues:dict];NSString *text = status.text;NSString *name = status.user.name;NSString *icon = status.user.icon;NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);// text=是啊，今天天气确实不错！, name=Jack, icon=lufy.pngNSString *text2 = status.retweetedStatus.text;NSString *name2 = status.retweetedStatus.user.name;NSString *icon2 = status.retweetedStatus.user.icon;NSLog(@\"text2=%@, name2=%@, icon2=%@\", text2, name2, icon2);// text2=今天天气真不错！, name2=Rose, icon2=nami.png 核心代码21[Status objectWithKeyValues:dict]` 3. 模型中有个数组属性，数组里面又要装着其它模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@interface Ad : NSObject@property (copy, nonatomic) NSString *image;@property (copy, nonatomic) NSString *url;@end@interface StatusResult : NSObject/** 存放着一堆的微博数据（里面都是Status模型） */@property (strong, nonatomic) NSMutableArray *statuses;/** 存放着一堆的广告数据（里面都是Ad模型） */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end@implementation StatusResult// 实现这个方法的目的：告诉MJExtension框架statuses和ads数组里面装的是什么模型/* + (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : [Status class], @\"ads\" : [Ad class] &#125;;&#125;+ (Class)objectClassInArray:(NSString *)propertyName&#123; if ([propertyName isEqualToString:@\"statuses\"]) &#123; return [Status class]; &#125; else if ([propertyName isEqualToString:@\"ads\"]) &#123; return [Ad class]; &#125; return nil;&#125;*/// 这个方法对比上面的2个方法更加没有侵入性和污染，因为不需要导入Status和Ad的头文件+ (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : @\"Status\", @\"ads\" : @\"Ad\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"statuses\" : @[ @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125;, @&#123; @\"text\" : @\"明天去旅游了\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125; &#125; ], @\"ads\" :@[ @&#123; @\"image\" : @\"ad01.png\", @\"url\" : @\"http://www.ad01.com\" &#125;, @&#123; @\"image\" : @\"ad02.png\", @\"url\" : @\"http://www.ad02.com\" &#125; ], @\"totalNumber\" : @\"2014\" &#125;; // 将字典转为StatusResult模型 StatusResult *result = [StatusResult objectWithKeyValues:dict]; NSLog(@\"totalNumber=%@\", result.totalNumber); // totalNumber=2014 // 打印statuses数组中的模型属性 for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);&#125; // text=今天天气真不错！, name=Rose, icon=nami.png // text=明天去旅游了, name=Jack, icon=lufy.png // 打印ads数组中的模型属性 for (Ad *ad in result.ads) &#123; NSLog(@\"image=%@, url=%@\", ad.image, ad.url);&#125; // image=ad01.png, url=http://www.ad01.com // image=ad02.png, url=http://www.ad02.com 核心代码3：123在模型内部实现+ (NSDictionary *)objectClassInArray方法[StatusResult objectWithKeyValues:dict] 4. 模型中的属性名和字典中的key不相同(或者需要多级映射)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface Bag : NSObject@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end@interface Student : NSObject@property (copy, nonatomic) NSString *ID;@property (copy, nonatomic) NSString *desc;@property (copy, nonatomic) NSString *nowName;@property (copy, nonatomic) NSString *oldName;@property (copy, nonatomic) NSString *nameChangedTime;@property (strong, nonatomic) Bag *bag;@end@implementation Student// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key+ (NSDictionary *)replacedKeyFromPropertyName&#123; return @&#123; @\"ID\" : @\"id\", @\"desc\" : @\"desciption\", @\"oldName\" : @\"name.oldName\", @\"nowName\" : @\"name.newName\", @\"nameChangedTime\" : @\"name.info.nameChangedTime\", @\"bag\" : @\"other.bag\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"id\" : @\"20\", @\"desciption\" : @\"孩子\", @\"name\" : @&#123; @\"newName\" : @\"lufy\", @\"oldName\" : @\"kitty\", @\"info\" : @&#123; @\"nameChangedTime\" : @\"2013-08\" &#125; &#125;, @\"other\" : @&#123; @\"bag\" : @&#123; @\"name\" : @\"小书包\", @\"price\" : @100.7 &#125; &#125; &#125;;// 将字典转为Student模型Student *stu = [Student objectWithKeyValues:dict];// 打印Student模型的属性NSLog(@\"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@\", stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);// ID=20, desc=孩子, oldName=kitty, nowName=lufy, nameChangedTime=2013-08NSLog(@\"bagName=%@, bagPrice=%f\", stu.bag.name, stu.bag.price);// bagName=小书包, bagPrice=100.700000 核心代码4：123在模型内部实现+ (NSDictionary *)replacedKeyFromPropertyName方法[Student objectWithKeyValues:dict] 5. 将一个字典数组转成模型数组123456789101112131415161718NSArray *dictArray = @[ @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", &#125;, @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\", &#125; ];// 将字典数组转为User模型数组NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];// 打印userArray数组中的User模型属性for (User *user in userArray) &#123; NSLog(@\"name=%@, icon=%@\", user.name, user.icon);&#125; // name=Jack, icon=lufy.png // name=Rose, icon=nami.png 核心代码5：1[User objectArrayWithKeyValuesArray:dictArray] 6. 将一个模型转成字典12345678// 新建模型 User *user = [[User alloc] init];user.name = @\"Jack\";user.icon = @\"lufy.png\";Status *status = [[Status alloc] init];status.user = user;status.text = @\"今天的心情不错！\"; ​1234567891011121314151617181920212223242526272829303132333435363738394041// 将模型转为字典NSDictionary *statusDict = status.keyValues;NSLog(@\"%@\", statusDict);/*&#123; text = \"今天的心情不错！\"; user = &#123; icon = \"lufy.png\"; name = Jack; &#125;; &#125;*/// 多级映射的模型Student *stu = [[Student alloc] init];stu.ID = @\"123\";stu.oldName = @\"rose\";stu.nowName = @\"jack\";stu.desc = @\"handsome\";stu.nameChangedTime = @\"2018-09-08\";Bag *bag = [[Bag alloc] init];bag.name = @\"小书包\";bag.price = 205;stu.bag = bag;NSDictionary *stuDict = stu.keyValues;NSLog(@\"%@\", stuDict);/*&#123; desciption = handsome; id = 123; name = &#123; info =&#123; nameChangedTime = \"2018-09-08\"; &#125;; newName = jack; oldName = rose; &#125;; other = &#123; bag =&#123; name = \"小书包\"; price = 205; &#125;; &#125;; &#125; */ 核心代码6：1status.keyValues、stu.keyValues 7. 将一个模型数组转成字典数组12345678910111213141516// 新建模型数组 User *user1 = [[User alloc] init];user1.name = @\"Jack\";user1.icon = @\"lufy.png\";User *user2 = [[User alloc] init];user2.name = @\"Rose\";user2.icon = @\"nami.png\";NSArray *userArray = @[user1, user2];// 将模型数组转为字典数组NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];NSLog(@\"%@\", dictArray);/*( &#123; icon = \"lufy.png\"; name = Jack; &#125;, &#123; icon = \"nami.png\"; name = Rose; &#125; )*/ 核心代码7：1[User keyValuesArrayWithObjectArray:userArray] 更多用法12参考NSObject+MJKeyValue.h参考NSObject+MJCoding.h","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UIScrollView的代理方法汇总","slug":"ios-uiscrollview-delegate-methods","date":"2019-02-02T03:15:37.000Z","updated":"2019-05-07T09:02:49.937Z","comments":true,"path":"2019-02-02-ios-uiscrollview-delegate-methods/","link":"","permalink":"https://paaatrick.com/2019-02-02-ios-uiscrollview-delegate-methods/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // any offset changes 只要scrollView的content 这个方法在任何方式触发 contentOffset // 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset // 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。// called on start of dragging (may require some time and or distance to move)- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; // 用户开始拖动 scroll view 的时候被调用，可能需要一些时间和距离移动之后才会触发。// called on finger up if the user dragged. velocity is in points/millisecond. // targetContentOffset may be changed to adjust where the scroll view comes to rest- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// 在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero//（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，//willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，// 当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，// 减速直到 targetContentOffset。- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;// 在用户结束拖动后被调用，decelerate 为 YES 时，// 结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，// scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，// 所以这个 dragging 属性的实际语义更接近 scrolling。- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // 减速动画开始前被调用。- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // 减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，// didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES。// 新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；// 如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // any zoom scale changes view缩放改变的时候调用。- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens告诉代理要缩放那个控件。 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // called before the scroll view begins zooming its content缩放开始的时候调用- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // scale between minimum and maximum. called after any 'bounce' animations缩放完毕的时候调用。- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // return a yes if you want to scroll to the top. if not defined, assumes YES- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top滚动动画完成时调用。@end","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UILabel的lineBreakMode省略模式设置","slug":"ios-uilabel-linebreakmode-setting","date":"2019-02-01T10:18:21.000Z","updated":"2019-05-07T09:02:49.935Z","comments":true,"path":"2019-02-01-ios-uilabel-linebreakmode-setting/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uilabel-linebreakmode-setting/","excerpt":"","text":"123456label.lineBreakMode = NSLineBreakByCharWrapping; //以字符为显示单位显示，后面部分省略不显示。label.lineBreakMode = NSLineBreakByClipping; //剪切与文本宽度相同的内容长度，后半部分被删除。label.lineBreakMode = NSLineBreakByTruncatingHead; //前面部分文字以……方式省略，显示尾部文字内容。label.lineBreakMode = NSLineBreakByTruncatingMiddle; //中间的内容以……方式省略，显示头尾的文字内容。label.lineBreakMode = NSLineBreakByTruncatingTail; //结尾部分的内容以……方式省略，显示头的文字内容。label.lineBreakMode = NSLineBreakByWordWrapping; //以单词为显示单位显示，后面部分省略不显示。","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS修改UIImage图片尺寸大小逻辑分辨率","slug":"ios-uiimage-resize","date":"2019-02-01T09:57:12.000Z","updated":"2019-05-07T09:02:49.934Z","comments":true,"path":"2019-02-01-ios-uiimage-resize/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uiimage-resize/","excerpt":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。","text":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。 123456789+ (UIImage *)imageResize:(UIImage*)img andResizeTo:(CGSize)newSize &#123; CGFloat scale = [[UIScreen mainScreen]scale]; //UIGraphicsBeginImageContext(newSize); UIGraphicsBeginImageContextWithOptions(newSize, NO, scale); [img drawInRect:CGRectMake(0,0,newSize.width,newSize.height)]; UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 这样一来就能使tabbar item的图标始终是25pt*25pt，恰到好处。 1childController.tabBarItem.selectedImage = [[SmallTools imageResize:[UIImage imageNamed:selected] andResizeTo:CGSizeMake(25, 25)] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 另外关于上图中间图标的动画效果实现可参考此文章iOS UITabbar图标点击动画效果实现","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UITabbar图标点击动画效果实现","slug":"ios-uitabbar-touch-animation","date":"2019-02-01T08:54:57.000Z","updated":"2019-05-07T09:02:49.936Z","comments":true,"path":"2019-02-01-ios-uitabbar-touch-animation/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uitabbar-touch-animation/","excerpt":"简介正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 方法一通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 方法二是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 效果图 第二种方法：只对image执行动画 1、带重力效果的弹跳","text":"简介正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 方法一通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 方法二是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 效果图 第二种方法：只对image执行动画 1、带重力效果的弹跳 后4个是第一种方法 2、先放大，再缩小 3、Z轴旋转 4、Y轴位移 5、放大并保持 代码实现获取要执行动画的Item12345678910111213141516171819202122232425262728293031323334353637383940414243@interface MainTabbarVC ()&lt;UITabBarControllerDelegate&gt;@property (nonatomic,assign) NSInteger indexFlag; //记录上一次点击tabbar，使用时，记得先在init或viewDidLoad里 初始化 = 0@end//第一种方法：通过接收点击事件对每个tabbar item的点击都执行动画-(void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item&#123; NSInteger index = [self.tabBar.items indexOfObject:item]; if (index != self.indexFlag) &#123; //执行动画 NSMutableArray *arry = [NSMutableArray array]; for (UIView *btn in self.tabBar.subviews) &#123; if ([btn isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; [arry addObject:btn]; &#125; &#125; //添加动画 //---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- self.indexFlag = index; &#125;&#125;//第二种方法：只想对某一个item的点击执行动画，且只有图片动，文字不动。并且其余图标的点击不带动画- (void)tabBarImageAnimation &#123; for (UIControl *tabBarButton in self.tabBar.subviews) &#123; if ([tabBarButton isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; for (UIControl *tabBarButtonLabel in tabBarButton.subviews) &#123; if ([tabBarButtonLabel isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) &#123; UILabel *label = (UILabel *)tabBarButtonLabel; //\"tab1\"到\"tab4\"分别是不打算执行动画的tabbar item的标题名称 if (![label.text isEqualToString:@\"tab1\"] &amp;&amp; ![label.text isEqualToString:@\"tab2\"] &amp;&amp; ![label.text isEqualToString:@\"tab3\"] &amp;&amp; ![label.text isEqualToString:@\"tab4\"]) &#123; for (UIView *imageView in tabBarButton.subviews) &#123; if ([imageView isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) &#123; //添加动画 //---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 第二种方法的用法比较灵活，比如可以在TabbarVC里设上面tabBarImageAnimation方法的通知Observer，在需要执行动画的地方比如打开某VC时在该VC的viewDidAppear里post通知即可。 动画代码1、带重力效果的弹跳 123456CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"transform.translation.y\"];//通过初中物理重力公式计算出的位移y值数组animation.values = @[@0.0, @-4.15, @-7.26, @-9.34, @-10.37, @-9.34, @-7.26, @-4.15, @0.0, @2.0, @-2.9, @-4.94, @-6.11, @-6.42, @-5.86, @-4.44, @-2.16, @0.0];animation.duration = 0.8;animation.beginTime = CACurrentMediaTime() + 1;[imageView.layer addAnimation:animation forKey:nil]; 2、先放大，再缩小 12345678910//放大效果，并回到原位CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.autoreverses = YES; //完成动画后会回到执行动画之前的状态animation.fromValue = [NSNumber numberWithFloat:0.7]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.3]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 3、Z轴旋转 12345678910//z轴旋转180度CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:M_PI]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 4、Y轴位移 12345678910//向上移动CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.translation.y\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:-10]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 5、放大并保持 1234567891011121314151617//放大效果CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards; //保证动画效果延续animation.fromValue = [NSNumber numberWithFloat:1.0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.15]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil];//移除其他tabbar的动画for (int i = 0; i&lt;arry.count; i++) &#123; if (i != index) &#123; [[arry[i] layer] removeAllAnimations]; &#125;&#125; 此外，如果想定制其他动画效果，还可以从下面属性里自己定制动画","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"比咪蒙更可怕的，是挖祖坟式举报清算","slug":"raistlin2017","date":"2019-01-31T16:00:50.000Z","updated":"2019-05-07T09:02:49.937Z","comments":true,"path":"2019-02-01-raistlin2017/","link":"","permalink":"https://paaatrick.com/2019-02-01-raistlin2017/","excerpt":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。","text":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。 就事论事的说，才华有限青年其实和咪蒙关系不大，那确实是个相对独立的团队，我也读过他们以前很多文章，很多都挺好看，要说有什么错，最多是有点煽动情绪。 但是做媒体嘛，又有几个不煽动情绪呢，只要不造谣，不引导邪恶的价值观，就没啥问题。 所以我觉得一个好的方式是，你不同意她的一篇文章，就说这篇文章写得不好写得不对，甚至可以说这篇文章写得用心险恶。 但你去挖她的出身，说她以前是咪蒙的实习生，所以一定不是什么好人。 就有点恶毒了。 比如有一位我挺喜欢的媒体人，这样写，我就觉得恶毒了 （而且如果真的翻了照片的话，较真的说这句话是造谣） 还有昨天整个朋友圈轰轰烈烈的”含咪量“测试，很多人号称朋友圈只要有人关注咪蒙了，就要和TA互删。 这我也觉得太过。按照他们的意思，也别管这人是谁，和他们是什么关系，是不是好朋友或者亲戚，也不管这个人关注咪蒙究竟是认同咪蒙的价值观还是就想围观一下或者学习排版，只要关注咪蒙，就要互删。这放在几十年前，我们叫做”划清界限“，流行这种运动的十年，是新中国最混乱的十年。当然我觉得更过的，还是下面这张截图。 咪蒙一边说这话，一边”永远爱国，永远热泪盈眶“恶不恶心？恶心。 咪蒙式毒鸡汤讨不讨厌？ 我也讨厌。但这样挖祖坟式清算举报，尤其是一直翻到2013年的微博，然后把相关机构全都@一遍的行为，让我感到很不舒服。这种不舒服不是反感，而是感到恐怖。而且这样的事情，这些年越来越多了。这样的待遇，陈一发遭遇过： 罗永浩遭遇过： 毕福剑也遭遇过： 普通网友当然也遭遇过： 动不动就呼吁封杀，虎扑和吴亦凡粉丝战斗时，双方都遭遇过。 游戏《阴阳师》遭遇过： 明星骂战的时候使用过这种武器。 社会热点事件就不说了，总是有成千上万人向团团举报。 现在甚至王者荣耀玩得不爽了，也要举报。 在这些举报里，网友们用不知道从哪里学到的词汇，给自己看着不爽的人扣上一个又一个大帽子，套上一个又一个罪名，其手法之纯熟，让我一度以为生活在冯骥才的《一百个人的十年》里。 可惜拿起手机瞧一瞧，发现已经是2019年了。 在我看来这种行为和看到让自己不爽的综艺，歌曲，电影就呼吁封杀是一样的，都是分不清各种权利界限的表现。就像几百年前，被人欺负了，就去衙门一跪，高喊“大人，我冤啊！”，然后期待青天大老爷给自己做主的古代中国人一样，始终没有长大。 他们自己是巨婴，却以为我国居民全都是长不大的巨婴，需要妈妈无微不至地照顾我们，帮我们挑好哪些是我们该看的，哪些是我们不该看的，然后只要他们看到自己不爽的，就会像孩子一样哭喊着叫妈妈来，希望妈妈把“坏东西”都打飞，然后才会重新喜笑颜开。 可惜现代法制社会没有，也不应该有青天大老爷——历史早已经证明了，青天大老爷式的人治，远不如法治来得公平高效，青天大老爷十年一遇，但手握权力，肆意滥用的昏官却遍地都是。 这已经很魔幻了。 但更魔幻的是，这些诉求，有时候还真的会得到回应。 以前我觉得孩子长不大，站不起来，是因为孩子自己笨，不想长大，后来才明白，孩子长不大，多半是有一个什么都替孩子做主，什么都替孩子决定的妈——在这些挖坟举报真的会得到回应的情况下，这样的行为永远不会停止，只会变本加厉。 即使如此，我还是希望你们能少挖坟，少呼吁封杀。 因为“封杀”这个词代表的那个行为，本来就不应该存在于这个世界上，并且当你习惯”封杀“之后，迟早有一天，会降临到你喜欢的那个账号，那个主播或者那个明星身上。 还记得之前整治八卦的时候吗？ 一开始封的很多账号，大家都讨厌，所以一片叫好声。结果之后发展到只要账号中带”八卦“两个字的，都被封号了，包括大家爱看的”毒舌电影“，”严肃八卦“，”金融八卦女“也全部都凉了。 最搞笑的是，我有个朋友，做了个账号叫”财经八卦阵“，那段时间只能改成”财经九卦阵“，终于躲过一劫。 还记得之前讨厌PGONE的人拼命举报PGONE，@了一大堆官方账号，要求对PGONE进行封杀吗？ 那会儿恰好GAI求婚成功，所以当时这些人中，有不少都人是通过捧GAI来踩PGONE的。 我自己也是GAI的粉丝，在一个GAI的粉丝群里，有几个姐们表示太好了，解气。但随即更多人表示这不是好事，因为GAI也有黑历史。 果然过了没多久，GAI被迫从《歌手》中退赛，至今也没在电视上再看过他。 在这样轰轰烈烈的挖坟式举报运动中，暴走漫画凉了，陈一发凉了，卢本伟凉了，毕福剑凉了，很多歌手明星都凉了。 PGONE被封杀你们叫好，GAI被封杀你们喊冤，毕福剑从央视消失你们想念他。你们以为这几件事不一样应该分开，但经历过这么多事情，你们应该明白，这两件事其实根本就是一件事。 封杀的人不会管哪个嘻哈歌手是正能量的，哪个是屡教不改的——既然嘻哈有问题，那就有问题的一起下。 就像现在这些为咪蒙的倒台拍手叫好的自媒体人，你又知道封杀的人分得清你和咪蒙的区别咯？ 况且在我看来，很多账号根本就和咪蒙没区别。 比如某个自媒体，洋洋洒洒写了几千字，细数咪蒙的”七宗罪“。 最后得出的结论是，咪蒙最大的罪就是她在迎合读者，并且标题低俗，危害极大。他把文章发到500人的新媒体群里，希望大家为他鼓掌叫好。 结果翻开他自己的公众号，标题却是这个画风的。 当有人在群里质问他，这是不是在迎合读者，标题低俗，危害极大的时候，他很坦诚的承认”可我的没人看啊。“ 让人心慌。 一个事实是，我们说的法制说的正义，从来不是给我们喜欢的东西准备的，我们喜欢的东西，根本不需要心中的那杆称来保护。 我们说的正义和法制，是你们讨厌的人，也有说话的权利，如果他们没有违法，就不应该不让他们说话。 还有一个事实是，咪蒙的价值观确实有问题，也许能煽动几十万人的情绪，是会让人焦虑，但真要说她改变了多少人三观，我觉得各位是高看文字的力量了。 一方面咪蒙并不产生三观，她一般只迎合大众情绪，另一方面三观这东西是没那么容易改变的，2019年了，文字早就没那么大力量了，现在如果说谁因为一篇文章三观就变了，那说明TA本来就有这样的想法，只是这篇文章正好支持了TA而已。 比起咪蒙，我更害怕那样因为讨厌一个人，就肆无忌惮地爆粗口，就想着要弄死对方，更害怕那样挖祖坟式的举报。 因为这让我觉得自己每时每刻都活在监视中，终日不得安宁。 现在你们觉得应该这样对付咪蒙，谁知道哪天我会不会受到这样的待遇。 而且说一千道一万，当年咪蒙写那几篇文章，疯狂在朋友圈转发刷屏，把咪蒙一度捧成微信第一大号的，还不是网友吗？ 看到某个去年还把咪蒙请为座上宾，一口一个咪蒙老师做分享的机构，昨天他们主编也开始测含咪率了，可能下一步就要表态”互删“了。 看到之前分享过致贱人几篇的人，开始在朋友圈说”想不通为什么这么多人会关注咪蒙“了。 有时候见多了这种昨天还万人追捧，今天就过街老鼠的戏码。真是让人对这个复杂繁复的世界，又害怕了几分呢。 -END-","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[]},{"title":"亲测真正好用的WordPress媒体库图片分类插件","slug":"wp-real-media-library","date":"2019-01-31T10:25:33.000Z","updated":"2019-05-07T09:02:49.934Z","comments":true,"path":"2019-01-31-wp-real-media-library/","link":"","permalink":"https://paaatrick.com/2019-01-31-wp-real-media-library/","excerpt":"","text":"WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以 然而实际使用起来极不方便，上传图片时不能选择上传到哪个分类，现有的图片也不能多选设置分类，需要点开每一张图片再勾选分类。 然后找到一个 WP Real Media Library 度娘盘找到了资源，下载后在WordPress插件界面上传使用。 使用起来非常顺手。 下载链接V4.0.10 度盘链接","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"云服务器使用WordPress搭建个人博客并绑定域名全记录","slug":"build-wordpress-blog","date":"2019-01-29T10:38:32.000Z","updated":"2019-05-07T09:02:49.933Z","comments":true,"path":"2019-01-29-build-wordpress-blog/","link":"","permalink":"https://paaatrick.com/2019-01-29-build-wordpress-blog/","excerpt":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。","text":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。 安装 Apache2、MySQL、PHP12sudo apt-get install apache2sudo apt-get install mysql-server mysql-client 测试一下Apache2是否成功安装：浏览器访问云服务器的IP，安装成功的话会显示Apache2的默认页面，It works。 安装php7.0，并安装apache的php扩展，再安装整合mysql和php的工具 123sudo apt-get install php7.0sudo apt-get install libapache2-mod-php7.0sudo apt-get install php7.0-mysql 重启一下Apache2和MySQL 12sudo service apache2 restartsudo service mysql restart 安装 phpmyadmin 这是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具。 1sudo apt-get install phpmyadmin 开启 apache 的 mod_rewrite，再重启一次apache 12sudo a2enmod rewritesudo service apache2 restart 先登录mysql mysql -u root -p ，输入密码 首先创建名为“wordpressdb”数据库，然后查看创建的数据库是否成功。 12create database wordpressdb;show databases; 看到图中出现自己创建的数据库。 给用户服务权限，下面的wordpressuser改为安装mysql时自己输入的用户名。 GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;FLUSH PRIVILEGES; 输入 exit;退出mysql，并再次重启服务。 12sudo service apache2 restartsudo service mysql restart 下载并配置WordPress用wget从WordPress官方网站下载安装包，放在 /var/www/html/ 目录，然后解压。 （最新版下载链接在 https://cn.wordpress.org/download/ 里面有） 123cd /var/www/html/sudo wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.zipsudo tar zxf wordpress-4.9.4.tar.gz 在 /var/www/html/wordpress/wp-content/ 下创建uploads。 然后更改上传目录权限，不然之后博客上传不了图片。 1234sudo mkdir uploadssudo chown -R www-data /var/www/html/wordpresssudo chmod -R 755 /var/www/html/wordpresssudo chown -R :www-data /var/www/html/wordpress/wp-content/uploads 配置wp-config-sample.php ，该文件在/var/www/html/wordpress/下 1sudo vi wp-config-sample.php 修改方法如下图所示： 浏览器访问 http://服务器IP地址/wordpress ，如果安装正常则进入wordpress的安装界面。 安装好后的效果如图： 到此建站完成。接下来申请域名并绑定服务器。 申请域名并配置DNS通过比价网站可以先大致看一下想要的域名价格 https://www.domcomp.com/ 看了一下知乎，大家推荐的域名供应商有 NameSilo 、Namecheap、Porkbun、GoDaddy等，亲测了一遍，发现 NameSilo 用户界面太丑；Namecheap 实际并不 cheap；最多人说的 GoDaddy 也偏贵但是支持支付宝，Porkbun 性价比高而且界面友好。 因为有境外支付的信用卡就不考虑 GoDaddy 了，直接在 Porkbun 上下单了一个 .com 域名，首年不到 7刀，续费 8.7刀。 值得一提的是支付时好几张卡支付失败，建行、农行都不行，换了广发的万事达才支付成功，有点迷。 付款后主页可以看到自己域名的各种详情，然后要设置的是 DNS RECORDS 点击Edit，添加两个A记录，分别是带www和不带的域名，ANSWER填自己的主机地址。 两个NS填DNS提供商的，这里因为Vultr自带了免费的DNS服务，直接填上去即可，具体的DNS地址可在Vultr的设置页里找。 下图就是设置页，可以看到底下有两条DNS地址，填到 Porkbun 里，然后还要在 Vultr 里 Add Domain，绑定服务器到域名。 两边都操作完成后，静候几分钟，然后访问一下自己的域名，应该就出来了。 常见问题在仪表盘的设置中不小心更改了wordpress地址后回不到后台在建站过程中，如果改动了 wordpress地址或站点地址，就回不到后台了。 解决方法：网站首页在wordpress目录下的index.php中的require这行的内容。 下图是wordpress下index.php的require所在行的内容。 最开始wordpress url是： 主机ip/wordpress。 它会自动去找index.php，然后就通过index.php里面的内容加载wordpress环境，更改了url后，就不能自动去找index.php了。此时后台也无法登录。解决这个问题，直接进数据库修改相关数据即可。操作如下。 1234567mysql -u root -p //然后输入密码show databases; //显示所有数据库use wordpressdb; //选中你自己网站对应的数据库。show tables; //显示该数据库所有表格。select * from wp_options where 1=1 limit 10; //查看数据库前10条记录update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;siteurl&apos;;//（如果home也改了就也改回来）update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;home&apos;; 其实就是改变了wordpress url ，则wp_options表中的siteurl的值变化了，只要把它在修改过来就行。 使用服务器IP（或域名）根地址直接访问网站首页此文章的建站方法是把所有东西都放在wordpress目录下，因此建完后，访问网站的网址为：主机IP/wordpresss。 通常情况下，我们会买一个域名与云主机IP绑定，输入IP地址只能访问根目录。 即/var/www/html，但是无法访问其下面的子目录。 以下将给出解决方案。如果使主机IP直接定位到网站首页。 第一种解决方式是把wordpress的内容直接都弄到根目录中，这是不提倡的，会使根目录变得杂乱。通常推荐第二种方案。 第二种方案操作如下： 登录后台，打开 设置→常规，修改站点地址。 WordPress地址是本体存放的地址，按本文安装的话就不用改动了。 站点地址是浏览器访问的地址，改为 “http://服务器IP（或域名）” 的形式，如下图即可。 同时，打开 设置→固定链接，把固定链接修改成如下形式：（去掉中间的/wordpress/） 至于文章后缀名，网上有关WordPress永久链接设置的介绍众多，普遍认为 /%postname%.html 是最佳的自定义永久链接形式。 这种形式将显示为:http://你的域名/日志标题.html，简单明了，有利于SEO。但当你的日志标题是中文时，文章标题以中文形式出现，看上去很不符合标准，或者可能会出现如:%64%b3%e8%ae%ar%e6%ba%a7%e5%9.html 类似乱码的显示。因此需要在编辑文章时，标题下面固定链接项，点击编辑，用拼音或英文输入文章标题。 然后把wordpress目录下的index.php 和 .htaccess文件复制一份到根目录下，.htaccess 是隐藏文件，可以使用ls -all。将其显示出来。注意是复制文件，原来目录下还存在。 123cd /var/www/html/wordpress/cp index.php /var/www/html/cp .htaccess /var/www/html/ 然后使用vim修改.htaccess文件的内容为下图所示。（默认文件如果就是如此则跳过该步骤） 修改index.php文件，因为index.php文件是wordpress下index.php的复制品，因此文件内部的require那一行的值当对于当前目录，是不正确的。同样使用vim编辑该文件，把require那一行路径，修改成下图那样。 此时再输入IP，看到还是It works界面，那是因为安装apache时，我们看到的It works界面其实是根目录下的index.html。当index.html 和 index.php同时存在时，默认还是打开index.html，所以应该把index.html移出该目录。我们把它移出到其他目录就行。 然后可能会产生下一个问题，设置固定链接后，文章页会404解决方法如下： 1sudo vi /etc/apache2/apache2.conf 把 AllowOverride None 改为 AllowOverride ALL 注意有两处要改，然后操作一下 12sudo a2enmod rewritesudo /etc/init.d/apache2 restar 刷新一下应该就能正常打开文章了。 主页样式修改 页尾和功能模块里的链接如果觉得碍眼，可以去除。 删除页尾“自豪地使用WordPress”字样 如果是通过函数生成页尾的主题，一般在模板函数那里修改，查找 “Proudly powered by” 的字样删掉就ok。 1&lt;a href=“&lt;?php echo esc\\_url( \\_\\_( ‘http://wordpress.org/’, ‘twentyeleven’ )); ?&gt;” title=“&lt;?php esc\\_attr\\_e(‘SemanticPersonalPublishing Platform’, ‘twentyeleven’ ); ?&gt;” rel=“generator”&gt;&lt;?php printf( __( ‘Proudly powered by%s’,‘twentyeleven’ ), ‘WordPress’ ); ?&gt;&lt;/a&gt; 删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”打开组件文件夹：wp-include/widgets/class-wp-widget-meta.php 找到代码段删除即可。 1234&lt;!\\-\\- 屏蔽 RSS 功能&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'rss2\\_url' )); ?&gt;\"&gt;&lt;?php \\_e('Entries &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'comments\\_rss2\\_url' )); ?&gt;\"&gt;&lt;?php _e('Comments &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;--&gt;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"性冷淡商务风：深圳龙华希尔顿逸林酒店","slug":"doubletree-longhua","date":"2017-05-16T16:00:50.000Z","updated":"2019-05-07T09:02:49.933Z","comments":true,"path":"2017-05-17-doubletree-longhua/","link":"","permalink":"https://paaatrick.com/2017-05-17-doubletree-longhua/","excerpt":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。","text":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。 一进大堂就是典型的 DoubleTree 性冷淡风格，米白色大理石为主的装修风格使原本较小的大堂显得大气，前台人手不够，客人多时要排队 CI/CO，上酒廊 Check-in 就更是要等很久了。 酒店被设计在这栋楼底部十几层，上半部分是写字楼，似乎业主不太重视酒店。 这次入住时房态紧张，只给升一级到12楼的园景房，虽然没升级到行政房不过也给了行政待遇。 DoubleTree 标志性的热曲奇饼，每位顾客入住时都给两份，很好吃，路过前台时可以再要几块。 因为是新开业的酒店，硬件水准在同品牌中数一数二，客房面积48平方起步也没什么问题，套房楼层据说被某剧组包了几个月，因此没能升级套房挺可惜的。 逸林标配单人浴缸，卫生间干湿分离，瑰珀翠（Crabtree &amp; Evelyn）的备品味道一般，还是更喜欢彼得罗夫（Peter Thomas Roth）的热情果味。 窗外正对龙华文化广场，也是新建的，晚上有大批广场舞大妈，幸好玻璃隔音性能不错，问题是晚上有治安的单车持续闪烁红蓝灯光，穿透力极强，不拉上遮光窗帘要被闪瞎眼。 床头音响支持直接插 iPhone 播放，插座自带USB也是这几年新开酒店的标配了。欢迎水果略显小气，进门的柜子另有玄机，水壶茶杯和小冰箱都藏在里面。 行政酒廊的 Happy Hour 从17点到19点，菜品十分丰富，热菜、甜品很多，当作晚餐完全没有问题。 酒店健身房还没装修好，把酒廊对面的一间套房改造成了一个临时健身房，所以面积很小，设备也不够多，来几个老外就占满了。室外泳池也要到17年5月底才开放。 回到房间发现已经开好了夜床，可能是看到一下子把两瓶水喝完了，于是又补充了六瓶😂而且很贴心地在床上放了张明日天气预报。 酒店的主餐厅名为 『OPEN | “開”全日餐厅』，然而晚上只营业到22点，并没有通宵开放😑 早餐看似丰富，实际出品一般，蛋卷和鸡肉肠还没有希尔顿花园的好吃。不过餐厅环境确实不错，适合平时晚上来吃自助餐。 这间 DoubleTree 最近几个月都不放基础房了，可能确实是商务客比较多吧， 10000分入住虽然没有华东一堆5000分 DoubleTree 那么白菜价，但毕竟地处深圳龙华腹地，性价比非常高，实属希尔顿保级优选。 原文始发于微信公众号（派大星星星星）：性冷淡商务风：深圳龙华希尔顿逸林酒店","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Hotel","slug":"Hotel","permalink":"https://paaatrick.com/tags/Hotel/"}]},{"title":"宜家 | 一个顺便卖卖家具的饭堂","slug":"ikea-canteen","date":"2015-12-16T16:00:50.000Z","updated":"2019-05-07T09:02:49.932Z","comments":true,"path":"2015-12-17-ikea-canteen/","link":"","permalink":"https://paaatrick.com/2015-12-17-ikea-canteen/","excerpt":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛","text":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛 然而事实上并不是这样的 宜家不只是卖家具 也卖非常多零碎玩意 很适合买来充实宿舍 但更重要的是它的餐厅 一个室友说 “宜家就是个顺便卖家具的食堂” 这话不假 这个餐厅不只是周末人满为患 即便是工作日也要找座位找很久 这还是宜家坐落在没有地铁经过的郊区的前提下 显得更为难得 ▲餐厅门口菜单 餐厅不算太大 菜单也很简单 主菜也就瑞典肉圆 蔬菜丸 肉酱面 三文鱼 西冷牛扒 牛肉饭等 最赞的就是瑞典肉圆了 不同于汕头牛肉丸爽口 弹性 有嚼劲 宜家的瑞典肉圆口感细腻 用料丰富 以猪肉和牛肉混合搅碎 加入牛奶 面包糠 切碎的洋葱 马铃薯粉或燕麦片 然后再加上白胡椒 盐 五香粉或肉桂等香料调味 搓匀后捏成球形 食用时配以肉酱 土豆泥 果酱以及一枚瑞典国旗 令人食指大动 西冷牛扒出品还算可以 虽然跟专门做牛扒的餐厅相比差距不小 但考虑到三十多的售价也能理解 还是值这个价的 烤三文鱼配通心粉 份量十足 不到三十块 价格感人 奥尔良鸡腿 表皮烤的焦焦的 肉质多汁嫩滑 跟肉丸一样也是必点 冷盘菜 香草三文鱼 酸黄瓜酱不会掩盖三文鱼的鲜美 反而相得益彰美味可口 宜家物价让人有种回到十年前的感觉 在深圳物价飞涨都快赶上香港的年代 还有这么个出品优良又便宜的餐厅实属不易 如果不是因为路途遥远交通不便利真的就成饭堂了 ▲取菜窗口超像饭堂 说是饭堂的另一个原因 顾客吃完后需要自己把餐盘放进回收车里 大大减少清洁阿姨工作量 ▲会员卡颜值颇高 记得办一张宜家的会员卡 在入口和收银台前都有免费申请的电脑 填完资料直接就吐卡出来了 工作日凭会员卡可以在餐厅免费喝咖啡 无限续杯的喔 而且很多单品都有会员优惠 比如这个两块九的杯子 新会员可以一块钱购买 值得一提的是毛巾和门垫 毛巾质量很好 不会掉毛 门垫价格感人 可以屯多几张在宿舍 脏了直接换一个 在收银台出来的地方还有一个小食档 五块钱的热狗套餐可以无限续杯 最近饮料都换成了相比可乐含糖量减半的北欧风味果味饮料 不过感觉还是以前的蔓越莓果汁好喝 还有就是十块三串的墨鱼丸 真心赞赞赞赞赞 外焦里嫩弹牙可口 墨鱼味十足 买买买后吃上一份墨鱼丸真是酸爽 还有同样十块三串的烤肠 味道跟乐凯撒的烤肠差不多 因为量不多 晚上七八点后可能就卖完了 同样强力推荐 见到了赶紧买三串 小食档旁边还有专门卖瑞典特产的超市 如果肉丸或者三文鱼吃的不过瘾还能买冷冻的回去自己煮 阻挡宜家成为饭堂的最大因素还是地理位置不好 公交非常不便利 只能自驾或者打车前往 不过不塞车的话从桂庙过去十分钟就能到 所以闲暇之余还是可以去吃餐饭的 原文始发于微信公众号（派大星星星星）：宜家 | 一个顺便卖卖家具的饭堂","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]},{"title":"一蘭拉面","slug":"ichiran-ramen","date":"2015-11-17T16:00:50.000Z","updated":"2019-05-07T09:02:49.932Z","comments":true,"path":"2015-11-18-ichiran-ramen/","link":"","permalink":"https://paaatrick.com/2015-11-18-ichiran-ramen/","excerpt":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。","text":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。 ▲座位都是一个个隔间 年初的时候，一兰除了日本本土外就只有铜锣湾一家分店，港岛线铜锣湾站C出口走5分钟谢斐道440号门面便是。店铺不算大，目测只能容纳50人，天黑了之后一直到凌晨三四点都要排队，22点左右高峰期甚至要排一个钟的队，不过为了吃上一碗一兰拉面，排队久一点也值得。 ▲铜锣湾店排队排出了店面 ▲空余座位展示，每个绿色格子代表一个座位 ▲只有一款面的菜单 排队快到的时候店员会给单你让你圈出偏好，我除了硬度喜欢偏硬一些外其他都是普通。偏硬是因为咬起来有口感。一碗89块港币的拉面，精华在于汤底，浓香而不腻，实打实用豚骨熬制，不加味精。吃完面后如果不喝汤就太浪费了。 ▲1/2倍辣 因为还是学生，钱不多，所以很少追加面底、温泉蛋、叉烧或者波子汽水。不过温泉蛋是真心好吃，建议尾巴们去的话一定要点一份。 秘制酱汁确实挺辣的，有一次被怂恿写了5倍辣，吃完整个人都不好了，当晚睡觉都睡不好。当然主要是因为我不太能吃辣，无辣不欢的尾巴可以试试20倍辣，很酸爽[doge] ▲5倍辣 店面是单人隔间，每个位置都有冷水水龙头，就算再冷的天也是冷水。网上的解释是 冰水的作用在於吃拉面时缓和浓厚的味道，同时有助口腔降温加快吃面速度，因为面太热而吃得慢，面浸汤糊烂的情况只会越来越严重。 冰水是多年来日式拉面的传统，春夏秋冬也不改。博主曾在下雪日子在拉面店外排队，店员会为等待的人送上热茶，但去到店内还是冰水。 希望大家不要因為气温10度时拉面店内送上冰水就破口大骂或上网劣评，人家日本人下雪时都未投诉。理解这原因后仍想要热水的话，向店员礼貌地要求就是了。 ▲每个座位上都有首次来店顾客指南，中英日各一份 今年年中的时候，一兰在尖沙咀棉登径8号负一楼开了第二家分店。不知道什么原因，很多地图上都还没有标记出来，尖沙咀N4出口出来就是了。 ▲高德地图 ▲尖沙咀店入口，店铺在负一楼 可能是因为在铜锣湾的第一家海外分店尝到了甜头，这家新分店面积很大，而且出现了一兰屋台，就是普通餐厅的座椅区，但我还是喜欢隔间多一点，毕竟隔间是一兰的特色，坐屋台的话没有感觉。 ▲尖沙咀店一兰屋台 ▲一兰方便面 一兰方便面，四五月份刚推出的时候有买单满200HKD送一个的活动，回来宿舍泡了一下发现挺一般的，跟店里吃的差距太大，不知道是方便面的问题还是我泡面方法不当[摊手]原价是198HKD五包，据说买一套的话里面会有特殊配料 ▲泡出来的效果，凭良心讲确实比合味道之类的好吃一些，但还不至于太好吃，不值那个价。 ▲方便面海报 ▲收银台 ▲收银台后面的展柜 月初去吃的时候发现账单多了一项额外10%的服务费，以前都没见过，不知道是最近才开始收的还是因为尖沙咀店比较大要额外收费。付款支持现金、八达通和银联卡，我预计不用太久，支付宝就会来插一脚，进一步方便大陆游客在香港游玩。 ▲尖沙咀店内海报 还没读大学的时候在广州住，每次去正佳和中华基本上都是吃博多一幸舍。博多刚进驻广州第一次吃的时候震惊了，怎么会有这么好吃的面，从此再也没吃过味千公仔面。 然而上大学后，某次安利别人博多时被反安利了一兰，这才发觉山外有山。 ▲铜锣湾店门面 一兰没有博多一幸舍的喧闹环境，店员们不会热血地齐声用日语喊欢迎光临，只会在隔间后面端面上来时说一声慢用（不会日语，猜的）然后落下帘子。店里如果没有小孩的话一般都挺安静。 另外不同于博多丰富的菜单，一兰只有一款面（好像最近新推出了一款沾面，不太记得了）。 ▲基友吃得正欢 在我有限的经历中，一兰拉面在我吃过的日本拉面中算是最好吃的了，一兰以其独特的隔间设计，只做一款面的坚持，极致浓香的汤底，口感细腻的面底赢得了大众的喜爱。有时候我嘴馋了也不怕劳累，专门从深圳湾过关搭巴士到天水围转港铁到尖沙咀来吃个面，也算是一兰真粉了。 大家如果去一兰，一定要预留多一些时间用来排队，以免耽误行程。[doge] 原文始发于微信公众号（派大星星星星）：一蘭拉面 2019.01更新 — 日本的一蘭拉面 2018年夏天去大阪和东京晃悠了一圈，路过不少一兰。 大阪 ▲大阪也超多人 ▲自助机器先付后食，这种机器是真的🐂🍺 ▲自助机出的票 ▲出品稳定，跟香港的几乎没区别 东京▲还是自助机，依然人多得一批 ▲还是一样的味道 ▲一样的抹茶豆腐","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]}]}