{"meta":{"title":"派大星星星星","subtitle":"你有没有给我带点鱼来","description":null,"author":"大星","url":"https://paaatrick.com","root":"/"},"pages":[{"title":"所有分类","date":"2019-03-22T12:14:27.260Z","updated":"2019-03-22T12:14:27.260Z","comments":true,"path":"categories/index.html","permalink":"https://paaatrick.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-03-22T12:14:27.261Z","updated":"2019-03-22T12:14:27.261Z","comments":true,"path":"tags/index.html","permalink":"https://paaatrick.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ios_file_system","slug":"ios-file-system","date":"2019-03-22T11:55:56.000Z","updated":"2019-03-22T12:14:27.259Z","comments":true,"path":"p/ios-file-system/","link":"","permalink":"https://paaatrick.com/p/ios-file-system/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS集成H5微信支付无法跳转的解决方案","slug":"ios-wxpay-h5-solution","date":"2019-03-22T10:12:20.000Z","updated":"2019-03-22T12:14:27.260Z","comments":true,"path":"p/ios-wxpay-h5-solution/","link":"","permalink":"https://paaatrick.com/p/ios-wxpay-h5-solution/","excerpt":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK(为了防苹果审核检测SDK，因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： 实现的效果是：App→微信→支付(成功失败或取消)→App","text":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK(为了防苹果审核检测SDK，因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： 实现的效果是：App→微信→支付(成功失败或取消)→App 前置准备本项目使用WKWebView，前置动作是后端小伙伴已经处理好微信H5支付下单链接，客户端接收到下单链接后的操作。 下单链接即为微信支付文档-统一下单API中返回的 mweb_url，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241。 操作步骤1. 添加 URL Scheme 并把微信加入白名单 添加 URL Scheme。在 xcodeproj 文件 Info 选项卡最下面的 URL Types内设置。 注意此URL的一级域名需要与微信商户后台(微信商户平台-产品中心-开发配置-H5支付)设置的的一级域名一致，比如微信商户里设置的是www.company.com，那 URL Schemes 可以设为 a1.company.com 。此特性使得一套H5支付可以方便得集成到多个App。 把微信的 URL Scheme 填入项目的白名单。在 xcodeproj 文件 Info 选项卡内的 LSApplicationQueriesSchemes字段里设置。 2. WKWebView加载链接添加协议 WKNavigationDelegate和WKUIDelegate。 创建一个WKWebView，并加载统一下单链接。 12345678910- (void)buildWKWebView &#123; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)]; [self.view addSubview:webView]; webView.navigationDelegate = self; webView.UIDelegate = self; NSURL *payURL = [NSURL URLWithString:self.payString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:payURL]; [request setValue:@\"a1.company.com://wxpaycallback/\" forHTTPHeaderField:@\"Referer\"]; [webView loadRequest:request];&#125; 此处self.payString就是后台传来的微信H5支付统一下单链接，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241。我们需要做的处理是根据文档给这个请求添加请求头Referer，关键在于这个既满足了微信检测到有商户后台设置好的一级域名，同时把这个链接做成了 URL Scheme 使得可以在跳转微信客户端后（不管支付成功还是失败）能顺利跳转回自己的App。wxpaycallback/可以任意设置方便在AppDelegate里处理跳转回来后部署业务逻辑。 3. 实现代理方法拦截链接并跳转微信1234567891011121314151617181920212223242526272829303132333435363738- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURLRequest *request = navigationAction.request; NSString *absoluteString = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding]; // 拦截WKWebView加载的微信支付统一下单链接, 将redirect_url参数修改为唤起自己App的URLScheme if ([absoluteString hasPrefix:@\"https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb\"] &amp;&amp; ![absoluteString hasSuffix:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]) &#123; decisionHandler(WKNavigationActionPolicyCancel); NSString *redirectUrl = nil; if ([absoluteString containsString:@\"redirect_url=\"]) &#123; NSRange redirectRange = [absoluteString rangeOfString:@\"redirect_url\"]; redirectUrl = [[absoluteString substringToIndex:redirectRange.location] stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; else &#123; redirectUrl = [absoluteString stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; NSMutableURLRequest *newRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:redirectUrl] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; newRequest.allHTTPHeaderFields = request.allHTTPHeaderFields; newRequest.URL = [NSURL URLWithString:redirectUrl]; [webView loadRequest:newRequest]; return; &#125; //拦截重定向的跳转微信的 URL Scheme, 打开微信 if ([absoluteString hasPrefix:@\"weixin://\"]) &#123; decisionHandler(WKNavigationActionPolicyAllow); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if ([[UIApplication sharedApplication] canOpenURL:navigationAction.request.URL]) &#123; [[UIApplication sharedApplication] openURL:navigationAction.request.URL]; &#125; else &#123; //未安装微信，自行处理 &#125; &#125;); return; &#125; decisionHandler(WKNavigationActionPolicyAllow); return;&#125; 4. AppDelegate 中接收跳转动作当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。 以下是AppDelegate接收返回动作的示例。 123456789101112131415- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; //safepay是支付宝H5支付的回调host if ([url.host isEqualToString:@\"wxpaycallback\"] || [url.host isEqualToString:@\"safepay\"]) &#123; // 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等 UITabBarController *tabBarVC = (UITabBarController *)topRootViewController; UINavigationController *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex]; [navVC popViewControllerAnimated:YES]; NSString *orderId = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayOrderId\"]; NSString *payFee = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayFee\"]; //以及更多参数 NSDictionary *resultDict = @&#123;@\"order_id\":orderId, @\"payFee\":payFee&#125;; [[NSNotificationCenter defaultCenter] postNotificationName:@\"htmlPaymentNotification\" object:self userInfo:resultDict]; &#125;&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"判断一个 NSArray 是否为空","slug":"if-nsarray-null","date":"2019-03-12T07:34:27.000Z","updated":"2019-03-22T12:14:27.259Z","comments":true,"path":"p/if-nsarray-null/","link":"","permalink":"https://paaatrick.com/p/if-nsarray-null/","excerpt":"","text":"1234if ([array isKindOfClass:[NSArray class]] &amp;&amp; array.count &gt; 0)&#123; NSLog(@\"这是一个非空数组\");&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iPhone屏幕各种尺寸分辨率（更新至XS）","slug":"iphone-pixel-point-size-scale","date":"2019-03-05T07:57:28.000Z","updated":"2019-03-22T12:14:27.258Z","comments":true,"path":"p/iphone-pixel-point-size-scale/","link":"","permalink":"https://paaatrick.com/p/iphone-pixel-point-size-scale/","excerpt":"","text":"Device Logic Point Logic Pixel Size Scale iPhone 2G 480 × 320 480 × 320 3.5 1x iPhone 3 480 × 320 480 × 320 3.5 1x iPhone 3GS 480 × 320 480 × 320 3.5 1x iPhone 4 480 × 320 960 × 640 3.5 2x iPhone 4S 480 × 320 960 × 640 3.5 2x iPhone 5 568 × 320 1136 × 640 4.0 2x iPhone 5S 568 × 320 1136 × 640 4.0 2x iPhone 5C 568 × 320 1136 × 640 4.0 2x iPhone 6 667 × 375 1334 × 750 4.7 2x iPhone 6 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 6S 667 × 375 1334 × 750 4.7 2x iPhone 6S Plus 736 × 414 2208 × 1242 5.5 3x iPhone SE 568 × 320 1136 × 640 4.0 2x iPhone 7 667 × 375 1334 × 750 4.7 2x iPhone 7 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 8 667 × 375 1334 × 750 4.7 2x iPhone 8 Plus 736 × 414 2208 × 1242 5.5 3x iPhone X 812 × 375 2436 × 1125 5.8 3x iPhone XS 812 × 375 2436 × 1125 5.8 3x iPhone XR 896 × 414 1792 × 828 6.1 2x iPhone XS Max 896 × 414 2688 × 1242 6.5 3x","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS 判断NSString值是否为空或null并转换为空字符串","slug":"transfer-null-to-nsstring","date":"2019-02-12T09:52:26.000Z","updated":"2019-03-22T12:14:27.257Z","comments":true,"path":"p/transfer-null-to-nsstring/","link":"","permalink":"https://paaatrick.com/p/transfer-null-to-nsstring/","excerpt":"","text":"遇到了一个后台json误将null作为字符串值导致iOS客户端崩溃闪退的问题，解决方法如下：套一层判断，如果是各种情况的null则转换为@””。 1234567+ (NSString *) nullToString:(id)string &#123; if ([string isEqual:@\"NULL\"] || [string isKindOfClass:[NSNull class]] || [string isEqual:[NSNull null]] || [string isEqual:NULL] || [[string class] isSubclassOfClass:[NSNull class]] || string == nil || string == NULL || [string isKindOfClass:[NSNull class]] || [[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] length]==0 || [string isEqualToString:@\"&lt;null&gt;\"] || [string isEqualToString:@\"(null)\"]) &#123; return @\"\"; &#125; else &#123; return (NSString *)string; &#125;&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS MJExtension使用方法指南(Objective-C)","slug":"mj-extension-guide","date":"2019-02-03T07:29:04.000Z","updated":"2019-03-22T12:14:27.257Z","comments":true,"path":"p/mj-extension-guide/","link":"","permalink":"https://paaatrick.com/p/mj-extension-guide/","excerpt":"","text":"MJExtension能做什么？1. MJExtension是一套字典和模型之间互相转换的超轻量级框架2. MJExtension能完成的功能1234字典（JSON） --&gt; 模型（Model）模型（Model） --&gt; 字典（JSON）字典数组（JSON Array） --&gt; 模型数组（Model Array）模型数组（Model Array） --&gt; 字典数组（JSON Array） 详尽用法主要参考 main.m中的各个函数 以及 NSObject+MJKeyValue.h MJExtension和JSONModel、Mantle等框架的区别1. 转换速率：最近一次测试表明：MJExtension &gt; JSONModel &gt; Mantle 各位开发者也可以自行测试 2. 具体用法：1234567891011JSONModel：要求所有模型类必须继承自JSONModel基类Mantle：要求所有模型类必须继承自MTModel基类MJExtension：不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 如何安装MJExtension方法一：cocoapods导入： 1pod 'MJExtension' 方法二：手动导入： 1234567891011121314151617将MJExtensionExample/MJExtensionExample/MJExtension文件夹中的所有源代码拽入项目中导入主头文件：#import \"MJExtension.h\"MJExtension.hMJConst.hMJConst.mMJFoundation.hMJFoundation.mMJIvar.hMJIvar.mMJType.hMJType.mNSObject+MJCoding.hNSObject+MJCoding.mNSObject+MJIvar.hNSObject+MJIvar.mNSObject+MJKeyValue.hNSObject+MJKeyValue.m 如何使用MJExtension1. 最简单的字典转模型12345678910111213141516171819202122232425typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;@property (copy, nonatomic) NSString *icon;@property (assign, nonatomic) int age;@property (assign, nonatomic) double height;@property (strong, nonatomic) NSNumber *money;@property (assign, nonatomic) Sex sex;@endNSDictionary *dict = @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", @\"age\" : @20, @\"height\" : @\"1.55\", @\"money\" : @100.9, @\"sex\" : @(SexFemale) &#125;;// 将字典转为User模型User *user = [User objectWithKeyValues:dict];NSLog(@\"name=%@, icon=%@, age=%d, height=%@, money=%@, sex=%d\", user.name, user.icon, user.age, user.height, user.money, user.sex);// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1 核心代码1：1[User objectWithKeyValues:dict] 2. 模型中嵌套模型12345678910111213141516171819202122232425262728293031323334353637@interface Status : NSObject/** 微博文本内容 */@property (copy, nonatomic) NSString *text;/** 微博作者 */@property (strong, nonatomic) User *user;/** 转发的微博 */@property (strong, nonatomic) Status *retweetedStatus;@endNSDictionary *dict = @&#123; @\"text\" : @\"是啊，今天天气确实不错！\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125;, @\"retweetedStatus\" : @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125; &#125;;// 将字典转为Status模型Status *status = [Status objectWithKeyValues:dict];NSString *text = status.text;NSString *name = status.user.name;NSString *icon = status.user.icon;NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);// text=是啊，今天天气确实不错！, name=Jack, icon=lufy.pngNSString *text2 = status.retweetedStatus.text;NSString *name2 = status.retweetedStatus.user.name;NSString *icon2 = status.retweetedStatus.user.icon;NSLog(@\"text2=%@, name2=%@, icon2=%@\", text2, name2, icon2);// text2=今天天气真不错！, name2=Rose, icon2=nami.png 核心代码21[Status objectWithKeyValues:dict]` 3. 模型中有个数组属性，数组里面又要装着其它模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@interface Ad : NSObject@property (copy, nonatomic) NSString *image;@property (copy, nonatomic) NSString *url;@end@interface StatusResult : NSObject/** 存放着一堆的微博数据（里面都是Status模型） */@property (strong, nonatomic) NSMutableArray *statuses;/** 存放着一堆的广告数据（里面都是Ad模型） */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end@implementation StatusResult// 实现这个方法的目的：告诉MJExtension框架statuses和ads数组里面装的是什么模型/* + (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : [Status class], @\"ads\" : [Ad class] &#125;;&#125;+ (Class)objectClassInArray:(NSString *)propertyName&#123; if ([propertyName isEqualToString:@\"statuses\"]) &#123; return [Status class]; &#125; else if ([propertyName isEqualToString:@\"ads\"]) &#123; return [Ad class]; &#125; return nil;&#125;*/// 这个方法对比上面的2个方法更加没有侵入性和污染，因为不需要导入Status和Ad的头文件+ (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : @\"Status\", @\"ads\" : @\"Ad\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"statuses\" : @[ @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125;, @&#123; @\"text\" : @\"明天去旅游了\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125; &#125; ], @\"ads\" :@[ @&#123; @\"image\" : @\"ad01.png\", @\"url\" : @\"http://www.ad01.com\" &#125;, @&#123; @\"image\" : @\"ad02.png\", @\"url\" : @\"http://www.ad02.com\" &#125; ], @\"totalNumber\" : @\"2014\" &#125;; // 将字典转为StatusResult模型 StatusResult *result = [StatusResult objectWithKeyValues:dict]; NSLog(@\"totalNumber=%@\", result.totalNumber); // totalNumber=2014 // 打印statuses数组中的模型属性 for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);&#125; // text=今天天气真不错！, name=Rose, icon=nami.png // text=明天去旅游了, name=Jack, icon=lufy.png // 打印ads数组中的模型属性 for (Ad *ad in result.ads) &#123; NSLog(@\"image=%@, url=%@\", ad.image, ad.url);&#125; // image=ad01.png, url=http://www.ad01.com // image=ad02.png, url=http://www.ad02.com 核心代码3：123在模型内部实现+ (NSDictionary *)objectClassInArray方法[StatusResult objectWithKeyValues:dict] 4. 模型中的属性名和字典中的key不相同(或者需要多级映射)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface Bag : NSObject@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end@interface Student : NSObject@property (copy, nonatomic) NSString *ID;@property (copy, nonatomic) NSString *desc;@property (copy, nonatomic) NSString *nowName;@property (copy, nonatomic) NSString *oldName;@property (copy, nonatomic) NSString *nameChangedTime;@property (strong, nonatomic) Bag *bag;@end@implementation Student// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key+ (NSDictionary *)replacedKeyFromPropertyName&#123; return @&#123; @\"ID\" : @\"id\", @\"desc\" : @\"desciption\", @\"oldName\" : @\"name.oldName\", @\"nowName\" : @\"name.newName\", @\"nameChangedTime\" : @\"name.info.nameChangedTime\", @\"bag\" : @\"other.bag\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"id\" : @\"20\", @\"desciption\" : @\"孩子\", @\"name\" : @&#123; @\"newName\" : @\"lufy\", @\"oldName\" : @\"kitty\", @\"info\" : @&#123; @\"nameChangedTime\" : @\"2013-08\" &#125; &#125;, @\"other\" : @&#123; @\"bag\" : @&#123; @\"name\" : @\"小书包\", @\"price\" : @100.7 &#125; &#125; &#125;;// 将字典转为Student模型Student *stu = [Student objectWithKeyValues:dict];// 打印Student模型的属性NSLog(@\"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@\", stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);// ID=20, desc=孩子, oldName=kitty, nowName=lufy, nameChangedTime=2013-08NSLog(@\"bagName=%@, bagPrice=%f\", stu.bag.name, stu.bag.price);// bagName=小书包, bagPrice=100.700000 核心代码4：123在模型内部实现+ (NSDictionary *)replacedKeyFromPropertyName方法[Student objectWithKeyValues:dict] 5. 将一个字典数组转成模型数组123456789101112131415161718NSArray *dictArray = @[ @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", &#125;, @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\", &#125; ];// 将字典数组转为User模型数组NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];// 打印userArray数组中的User模型属性for (User *user in userArray) &#123; NSLog(@\"name=%@, icon=%@\", user.name, user.icon);&#125; // name=Jack, icon=lufy.png // name=Rose, icon=nami.png 核心代码5：1[User objectArrayWithKeyValuesArray:dictArray] 6. 将一个模型转成字典12345678// 新建模型 User *user = [[User alloc] init];user.name = @\"Jack\";user.icon = @\"lufy.png\";Status *status = [[Status alloc] init];status.user = user;status.text = @\"今天的心情不错！\"; ​1234567891011121314151617181920212223242526272829303132333435363738394041// 将模型转为字典NSDictionary *statusDict = status.keyValues;NSLog(@\"%@\", statusDict);/*&#123; text = \"今天的心情不错！\"; user = &#123; icon = \"lufy.png\"; name = Jack; &#125;; &#125;*/// 多级映射的模型Student *stu = [[Student alloc] init];stu.ID = @\"123\";stu.oldName = @\"rose\";stu.nowName = @\"jack\";stu.desc = @\"handsome\";stu.nameChangedTime = @\"2018-09-08\";Bag *bag = [[Bag alloc] init];bag.name = @\"小书包\";bag.price = 205;stu.bag = bag;NSDictionary *stuDict = stu.keyValues;NSLog(@\"%@\", stuDict);/*&#123; desciption = handsome; id = 123; name = &#123; info =&#123; nameChangedTime = \"2018-09-08\"; &#125;; newName = jack; oldName = rose; &#125;; other = &#123; bag =&#123; name = \"小书包\"; price = 205; &#125;; &#125;; &#125; */ 核心代码6：1status.keyValues、stu.keyValues 7. 将一个模型数组转成字典数组12345678910111213141516// 新建模型数组 User *user1 = [[User alloc] init];user1.name = @\"Jack\";user1.icon = @\"lufy.png\";User *user2 = [[User alloc] init];user2.name = @\"Rose\";user2.icon = @\"nami.png\";NSArray *userArray = @[user1, user2];// 将模型数组转为字典数组NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];NSLog(@\"%@\", dictArray);/*( &#123; icon = \"lufy.png\"; name = Jack; &#125;, &#123; icon = \"nami.png\"; name = Rose; &#125; )*/ 核心代码7：1[User keyValuesArrayWithObjectArray:userArray] 更多用法12参考NSObject+MJKeyValue.h参考NSObject+MJCoding.h","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UIScrollView的代理方法汇总","slug":"ios-uiscrollview-delegate-methods","date":"2019-02-02T03:15:37.000Z","updated":"2019-03-22T12:14:27.256Z","comments":true,"path":"p/ios-uiscrollview-delegate-methods/","link":"","permalink":"https://paaatrick.com/p/ios-uiscrollview-delegate-methods/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // any offset changes 只要scrollView的content 这个方法在任何方式触发 contentOffset // 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset // 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。// called on start of dragging (may require some time and or distance to move)- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; // 用户开始拖动 scroll view 的时候被调用，可能需要一些时间和距离移动之后才会触发。// called on finger up if the user dragged. velocity is in points/millisecond. // targetContentOffset may be changed to adjust where the scroll view comes to rest- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// 在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero//（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，//willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，// 当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，// 减速直到 targetContentOffset。- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;// 在用户结束拖动后被调用，decelerate 为 YES 时，// 结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，// scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，// 所以这个 dragging 属性的实际语义更接近 scrolling。- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // 减速动画开始前被调用。- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // 减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，// didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES。// 新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；// 如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // any zoom scale changes view缩放改变的时候调用。- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens告诉代理要缩放那个控件。 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // called before the scroll view begins zooming its content缩放开始的时候调用- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // scale between minimum and maximum. called after any 'bounce' animations缩放完毕的时候调用。- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // return a yes if you want to scroll to the top. if not defined, assumes YES- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top滚动动画完成时调用。@end","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UILabel的lineBreakMode省略模式设置","slug":"ios-uilabel-linebreakmode-setting","date":"2019-02-01T10:18:21.000Z","updated":"2019-03-22T12:14:27.251Z","comments":true,"path":"p/ios-uilabel-linebreakmode-setting/","link":"","permalink":"https://paaatrick.com/p/ios-uilabel-linebreakmode-setting/","excerpt":"","text":"123456label.lineBreakMode = NSLineBreakByCharWrapping; //以字符为显示单位显示，后面部分省略不显示。label.lineBreakMode = NSLineBreakByClipping; //剪切与文本宽度相同的内容长度，后半部分被删除。label.lineBreakMode = NSLineBreakByTruncatingHead; //前面部分文字以……方式省略，显示尾部文字内容。label.lineBreakMode = NSLineBreakByTruncatingMiddle; //中间的内容以……方式省略，显示头尾的文字内容。label.lineBreakMode = NSLineBreakByTruncatingTail; //结尾部分的内容以……方式省略，显示头的文字内容。label.lineBreakMode = NSLineBreakByWordWrapping; //以单词为显示单位显示，后面部分省略不显示。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS修改UIImage图片尺寸大小逻辑分辨率","slug":"ios-uiimage-resize","date":"2019-02-01T09:57:12.000Z","updated":"2019-03-22T12:14:27.251Z","comments":true,"path":"p/ios-uiimage-resize/","link":"","permalink":"https://paaatrick.com/p/ios-uiimage-resize/","excerpt":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。","text":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。 123456789+ (UIImage *)imageResize:(UIImage*)img andResizeTo:(CGSize)newSize &#123; CGFloat scale = [[UIScreen mainScreen]scale]; //UIGraphicsBeginImageContext(newSize); UIGraphicsBeginImageContextWithOptions(newSize, NO, scale); [img drawInRect:CGRectMake(0,0,newSize.width,newSize.height)]; UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 这样一来就能使tabbar item的图标始终是25pt*25pt，恰到好处。 1childController.tabBarItem.selectedImage = [[SmallTools imageResize:[UIImage imageNamed:selected] andResizeTo:CGSizeMake(25, 25)] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 另外关于上图中间图标的动画效果实现可参考此文章iOS UITabbar图标点击动画效果实现","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UITabbar图标点击动画效果实现","slug":"ios-uitabbar-touch-animation","date":"2019-02-01T08:54:57.000Z","updated":"2019-03-22T12:14:27.254Z","comments":true,"path":"p/ios-uitabbar-touch-animation/","link":"","permalink":"https://paaatrick.com/p/ios-uitabbar-touch-animation/","excerpt":"正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 第一种通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 第二种是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 先上几个效果图： 1、带重力效果的弹跳（第二种方法：只对image执行动画）","text":"正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 第一种通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 第二种是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 先上几个效果图： 1、带重力效果的弹跳（第二种方法：只对image执行动画） 2、先放大，再缩小 3、Z轴旋转 4、Y轴位移 5、放大并保持 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface MainTabbarVC ()&lt;UITabBarControllerDelegate&gt;@property (nonatomic,assign) NSInteger indexFlag; //记录上一次点击tabbar，使用时，记得先在init或viewDidLoad里 初始化 = 0@end//第一种方法：通过接收点击事件对每个tabbar item的点击都执行动画-(void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item&#123; NSInteger index = [self.tabBar.items indexOfObject:item]; if (index != self.indexFlag) &#123; //执行动画 NSMutableArray *arry = [NSMutableArray array]; for (UIView *btn in self.tabBar.subviews) &#123; if ([btn isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; [arry addObject:btn]; &#125; &#125; //添加动画 //---将下面的代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- self.indexFlag = index; &#125;&#125;//第二种方法：只想对某一个item的点击执行动画，且只有图片动，文字不动。并且其余图标的点击不带动画- (void)tabBarImageAnimation &#123; for (UIControl *tabBarButton in self.tabBar.subviews) &#123; if ([tabBarButton isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; for (UIControl *tabBarButtonLabel in tabBarButton.subviews) &#123; if ([tabBarButtonLabel isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) &#123; UILabel *label = (UILabel *)tabBarButtonLabel; //\"tab1\"到\"tab4\"分别是不打算执行动画的tabbar item的标题名称 if (![label.text isEqualToString:@\"tab1\"] &amp;&amp; ![label.text isEqualToString:@\"tab2\"] &amp;&amp; ![label.text isEqualToString:@\"tab3\"] &amp;&amp; ![label.text isEqualToString:@\"tab4\"]) &#123; for (UIView *imageView in tabBarButton.subviews) &#123; if ([imageView isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) &#123; //添加动画 //---将下面的代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 1、带重力效果的弹跳 123456CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"transform.translation.y\"];//通过初中物理重力公式计算出的位移y值数组animation.values = @[@0.0, @-4.15, @-7.26, @-9.34, @-10.37, @-9.34, @-7.26, @-4.15, @0.0, @2.0, @-2.9, @-4.94, @-6.11, @-6.42, @-5.86, @-4.44, @-2.16, @0.0];animation.duration = 0.8;animation.beginTime = CACurrentMediaTime() + 1;[imageView.layer addAnimation:animation forKey:nil]; 2、先放大，再缩小 12345678910//放大效果，并回到原位CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.autoreverses = YES; //完成动画后会回到执行动画之前的状态animation.fromValue = [NSNumber numberWithFloat:0.7]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.3]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 3、Z轴旋转 12345678910//z轴旋转180度CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:M_PI]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 4、Y轴位移 12345678910//向上移动CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.translation.y\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:-10]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 5、放大并保持 1234567891011121314151617//放大效果CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards; //保证动画效果延续animation.fromValue = [NSNumber numberWithFloat:1.0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.15]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil];//移除其他tabbar的动画for (int i = 0; i&lt;arry.count; i++) &#123; if (i != index) &#123; [[arry[i] layer] removeAllAnimations]; &#125;&#125; 此外，如果想定制其他动画效果，还可以从下面属性里自己定制动画","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"比咪蒙更可怕的，是挖祖坟式举报清算","slug":"raistlin2017","date":"2019-01-31T16:00:50.000Z","updated":"2019-03-22T12:14:27.255Z","comments":true,"path":"p/raistlin2017/","link":"","permalink":"https://paaatrick.com/p/raistlin2017/","excerpt":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。","text":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。 就事论事的说，才华有限青年其实和咪蒙关系不大，那确实是个相对独立的团队，我也读过他们以前很多文章，很多都挺好看，要说有什么错，最多是有点煽动情绪。 但是做媒体嘛，又有几个不煽动情绪呢，只要不造谣，不引导邪恶的价值观，就没啥问题。 所以我觉得一个好的方式是，你不同意她的一篇文章，就说这篇文章写得不好写得不对，甚至可以说这篇文章写得用心险恶。 但你去挖她的出身，说她以前是咪蒙的实习生，所以一定不是什么好人。 就有点恶毒了。 比如有一位我挺喜欢的媒体人，这样写，我就觉得恶毒了 （而且如果真的翻了照片的话，较真的说这句话是造谣） 还有昨天整个朋友圈轰轰烈烈的”含咪量“测试，很多人号称朋友圈只要有人关注咪蒙了，就要和TA互删。 这我也觉得太过。按照他们的意思，也别管这人是谁，和他们是什么关系，是不是好朋友或者亲戚，也不管这个人关注咪蒙究竟是认同咪蒙的价值观还是就想围观一下或者学习排版，只要关注咪蒙，就要互删。这放在几十年前，我们叫做”划清界限“，流行这种运动的十年，是新中国最混乱的十年。当然我觉得更过的，还是下面这张截图。 咪蒙一边说这话，一边”永远爱国，永远热泪盈眶“恶不恶心？恶心。 咪蒙式毒鸡汤讨不讨厌？ 我也讨厌。但这样挖祖坟式清算举报，尤其是一直翻到2013年的微博，然后把相关机构全都@一遍的行为，让我感到很不舒服。这种不舒服不是反感，而是感到恐怖。而且这样的事情，这些年越来越多了。这样的待遇，陈一发遭遇过： 罗永浩遭遇过： 毕福剑也遭遇过： 普通网友当然也遭遇过： 动不动就呼吁封杀，虎扑和吴亦凡粉丝战斗时，双方都遭遇过。 游戏《阴阳师》遭遇过： 明星骂战的时候使用过这种武器。 社会热点事件就不说了，总是有成千上万人向团团举报。 现在甚至王者荣耀玩得不爽了，也要举报。 在这些举报里，网友们用不知道从哪里学到的词汇，给自己看着不爽的人扣上一个又一个大帽子，套上一个又一个罪名，其手法之纯熟，让我一度以为生活在冯骥才的《一百个人的十年》里。 可惜拿起手机瞧一瞧，发现已经是2019年了。 在我看来这种行为和看到让自己不爽的综艺，歌曲，电影就呼吁封杀是一样的，都是分不清各种权利界限的表现。就像几百年前，被人欺负了，就去衙门一跪，高喊“大人，我冤啊！”，然后期待青天大老爷给自己做主的古代中国人一样，始终没有长大。 他们自己是巨婴，却以为我国居民全都是长不大的巨婴，需要妈妈无微不至地照顾我们，帮我们挑好哪些是我们该看的，哪些是我们不该看的，然后只要他们看到自己不爽的，就会像孩子一样哭喊着叫妈妈来，希望妈妈把“坏东西”都打飞，然后才会重新喜笑颜开。 可惜现代法制社会没有，也不应该有青天大老爷——历史早已经证明了，青天大老爷式的人治，远不如法治来得公平高效，青天大老爷十年一遇，但手握权力，肆意滥用的昏官却遍地都是。 这已经很魔幻了。 但更魔幻的是，这些诉求，有时候还真的会得到回应。 以前我觉得孩子长不大，站不起来，是因为孩子自己笨，不想长大，后来才明白，孩子长不大，多半是有一个什么都替孩子做主，什么都替孩子决定的妈——在这些挖坟举报真的会得到回应的情况下，这样的行为永远不会停止，只会变本加厉。 即使如此，我还是希望你们能少挖坟，少呼吁封杀。 因为“封杀”这个词代表的那个行为，本来就不应该存在于这个世界上，并且当你习惯”封杀“之后，迟早有一天，会降临到你喜欢的那个账号，那个主播或者那个明星身上。 还记得之前整治八卦的时候吗？ 一开始封的很多账号，大家都讨厌，所以一片叫好声。结果之后发展到只要账号中带”八卦“两个字的，都被封号了，包括大家爱看的”毒舌电影“，”严肃八卦“，”金融八卦女“也全部都凉了。 最搞笑的是，我有个朋友，做了个账号叫”财经八卦阵“，那段时间只能改成”财经九卦阵“，终于躲过一劫。 还记得之前讨厌PGONE的人拼命举报PGONE，@了一大堆官方账号，要求对PGONE进行封杀吗？ 那会儿恰好GAI求婚成功，所以当时这些人中，有不少都人是通过捧GAI来踩PGONE的。 我自己也是GAI的粉丝，在一个GAI的粉丝群里，有几个姐们表示太好了，解气。但随即更多人表示这不是好事，因为GAI也有黑历史。 果然过了没多久，GAI被迫从《歌手》中退赛，至今也没在电视上再看过他。 在这样轰轰烈烈的挖坟式举报运动中，暴走漫画凉了，陈一发凉了，卢本伟凉了，毕福剑凉了，很多歌手明星都凉了。 PGONE被封杀你们叫好，GAI被封杀你们喊冤，毕福剑从央视消失你们想念他。你们以为这几件事不一样应该分开，但经历过这么多事情，你们应该明白，这两件事其实根本就是一件事。 封杀的人不会管哪个嘻哈歌手是正能量的，哪个是屡教不改的——既然嘻哈有问题，那就有问题的一起下。 就像现在这些为咪蒙的倒台拍手叫好的自媒体人，你又知道封杀的人分得清你和咪蒙的区别咯？ 况且在我看来，很多账号根本就和咪蒙没区别。 比如某个自媒体，洋洋洒洒写了几千字，细数咪蒙的”七宗罪“。 最后得出的结论是，咪蒙最大的罪就是她在迎合读者，并且标题低俗，危害极大。他把文章发到500人的新媒体群里，希望大家为他鼓掌叫好。 结果翻开他自己的公众号，标题却是这个画风的。 当有人在群里质问他，这是不是在迎合读者，标题低俗，危害极大的时候，他很坦诚的承认”可我的没人看啊。“ 让人心慌。 一个事实是，我们说的法制说的正义，从来不是给我们喜欢的东西准备的，我们喜欢的东西，根本不需要心中的那杆称来保护。 我们说的正义和法制，是你们讨厌的人，也有说话的权利，如果他们没有违法，就不应该不让他们说话。 还有一个事实是，咪蒙的价值观确实有问题，也许能煽动几十万人的情绪，是会让人焦虑，但真要说她改变了多少人三观，我觉得各位是高看文字的力量了。 一方面咪蒙并不产生三观，她一般只迎合大众情绪，另一方面三观这东西是没那么容易改变的，2019年了，文字早就没那么大力量了，现在如果说谁因为一篇文章三观就变了，那说明TA本来就有这样的想法，只是这篇文章正好支持了TA而已。 比起咪蒙，我更害怕那样因为讨厌一个人，就肆无忌惮地爆粗口，就想着要弄死对方，更害怕那样挖祖坟式的举报。 因为这让我觉得自己每时每刻都活在监视中，终日不得安宁。 现在你们觉得应该这样对付咪蒙，谁知道哪天我会不会受到这样的待遇。 而且说一千道一万，当年咪蒙写那几篇文章，疯狂在朋友圈转发刷屏，把咪蒙一度捧成微信第一大号的，还不是网友吗？ 看到某个去年还把咪蒙请为座上宾，一口一个咪蒙老师做分享的机构，昨天他们主编也开始测含咪率了，可能下一步就要表态”互删“了。 看到之前分享过致贱人几篇的人，开始在朋友圈说”想不通为什么这么多人会关注咪蒙“了。 有时候见多了这种昨天还万人追捧，今天就过街老鼠的戏码。真是让人对这个复杂繁复的世界，又害怕了几分呢。 -END-","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[]},{"title":"亲测真正好用的WordPress媒体库图片分类插件","slug":"wp-real-media-library","date":"2019-01-31T10:25:33.000Z","updated":"2019-03-22T12:14:27.250Z","comments":true,"path":"p/wp-real-media-library/","link":"","permalink":"https://paaatrick.com/p/wp-real-media-library/","excerpt":"","text":"WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以 然而实际使用起来极不方便，上传图片时不能选择上传到哪个分类，现有的图片也不能多选设置分类，需要点开每一张图片再勾选分类。 然后找到一个 WP Real Media Library 度娘盘找到了资源，下载后在WordPress插件界面上传使用。 使用起来非常顺手。 下载链接V4.0.10 度盘链接","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"云服务器使用WordPress搭建个人博客并绑定域名全记录","slug":"build-wordpress-blog","date":"2019-01-29T10:38:32.000Z","updated":"2019-03-22T12:14:27.249Z","comments":true,"path":"p/build-wordpress-blog/","link":"","permalink":"https://paaatrick.com/p/build-wordpress-blog/","excerpt":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。","text":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。 安装 Apache2、MySQL、PHP12sudo apt-get install apache2sudo apt-get install mysql-server mysql-client 测试一下Apache2是否成功安装：浏览器访问云服务器的IP，安装成功的话会显示Apache2的默认页面，It works。 安装php7.0，并安装apache的php扩展，再安装整合mysql和php的工具 123sudo apt-get install php7.0sudo apt-get install libapache2-mod-php7.0sudo apt-get install php7.0-mysql 重启一下Apache2和MySQL 12sudo service apache2 restartsudo service mysql restart 安装 phpmyadmin 这是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具。 1sudo apt-get install phpmyadmin 开启 apache 的 mod_rewrite，再重启一次apache 12sudo a2enmod rewritesudo service apache2 restart 先登录mysql mysql -u root -p ，输入密码 首先创建名为“wordpressdb”数据库，然后查看创建的数据库是否成功。 12create database wordpressdb;show databases; 看到图中出现自己创建的数据库。 给用户服务权限，下面的wordpressuser改为安装mysql时自己输入的用户名。 GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;FLUSH PRIVILEGES; 输入 exit;退出mysql，并再次重启服务。 12sudo service apache2 restartsudo service mysql restart 下载并配置WordPress用wget从WordPress官方网站下载安装包，放在 /var/www/html/ 目录，然后解压。 （最新版下载链接在 https://cn.wordpress.org/download/ 里面有） 123cd /var/www/html/sudo wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.zipsudo tar zxf wordpress-4.9.4.tar.gz 在 /var/www/html/wordpress/wp-content/ 下创建uploads。 然后更改上传目录权限，不然之后博客上传不了图片。 1234sudo mkdir uploadssudo chown -R www-data /var/www/html/wordpresssudo chmod -R 755 /var/www/html/wordpresssudo chown -R :www-data /var/www/html/wordpress/wp-content/uploads 配置wp-config-sample.php ，该文件在/var/www/html/wordpress/下 1sudo vi wp-config-sample.php 修改方法如下图所示： 浏览器访问 http://服务器IP地址/wordpress ，如果安装正常则进入wordpress的安装界面。 安装好后的效果如图： 到此建站完成。接下来申请域名并绑定服务器。 申请域名并配置DNS通过比价网站可以先大致看一下想要的域名价格 https://www.domcomp.com/ 看了一下知乎，大家推荐的域名供应商有 NameSilo 、Namecheap、Porkbun、GoDaddy等，亲测了一遍，发现 NameSilo 用户界面太丑；Namecheap 实际并不 cheap；最多人说的 GoDaddy 也偏贵但是支持支付宝，Porkbun 性价比高而且界面友好。 因为有境外支付的信用卡就不考虑 GoDaddy 了，直接在 Porkbun 上下单了一个 .com 域名，首年不到 7刀，续费 8.7刀。 值得一提的是支付时好几张卡支付失败，建行、农行都不行，换了广发的万事达才支付成功，有点迷。 付款后主页可以看到自己域名的各种详情，然后要设置的是 DNS RECORDS 点击Edit，添加两个A记录，分别是带www和不带的域名，ANSWER填自己的主机地址。 两个NS填DNS提供商的，这里因为Vultr自带了免费的DNS服务，直接填上去即可，具体的DNS地址可在Vultr的设置页里找。 下图就是设置页，可以看到底下有两条DNS地址，填到 Porkbun 里，然后还要在 Vultr 里 Add Domain，绑定服务器到域名。 两边都操作完成后，静候几分钟，然后访问一下自己的域名，应该就出来了。 常见问题在仪表盘的设置中不小心更改了wordpress地址后回不到后台在建站过程中，如果改动了 wordpress地址或站点地址，就回不到后台了。 解决方法：网站首页在wordpress目录下的index.php中的require这行的内容。 下图是wordpress下index.php的require所在行的内容。 最开始wordpress url是： 主机ip/wordpress。 它会自动去找index.php，然后就通过index.php里面的内容加载wordpress环境，更改了url后，就不能自动去找index.php了。此时后台也无法登录。解决这个问题，直接进数据库修改相关数据即可。操作如下。 1234567mysql -u root -p //然后输入密码show databases; //显示所有数据库use wordpressdb; //选中你自己网站对应的数据库。show tables; //显示该数据库所有表格。select * from wp_options where 1=1 limit 10; //查看数据库前10条记录update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;siteurl&apos;;//（如果home也改了就也改回来）update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;home&apos;; 其实就是改变了wordpress url ，则wp_options表中的siteurl的值变化了，只要把它在修改过来就行。 使用服务器IP（或域名）根地址直接访问网站首页此文章的建站方法是把所有东西都放在wordpress目录下，因此建完后，访问网站的网址为：主机IP/wordpresss。 通常情况下，我们会买一个域名与云主机IP绑定，输入IP地址只能访问根目录。 即/var/www/html，但是无法访问其下面的子目录。 以下将给出解决方案。如果使主机IP直接定位到网站首页。 第一种解决方式是把wordpress的内容直接都弄到根目录中，这是不提倡的，会使根目录变得杂乱。通常推荐第二种方案。 第二种方案操作如下： 登录后台，打开 设置→常规，修改站点地址。 WordPress地址是本体存放的地址，按本文安装的话就不用改动了。 站点地址是浏览器访问的地址，改为 “http://服务器IP（或域名）” 的形式，如下图即可。 同时，打开 设置→固定链接，把固定链接修改成如下形式：（去掉中间的/wordpress/） 至于文章后缀名，网上有关WordPress永久链接设置的介绍众多，普遍认为 /%postname%.html 是最佳的自定义永久链接形式。 这种形式将显示为:http://你的域名/日志标题.html，简单明了，有利于SEO。但当你的日志标题是中文时，文章标题以中文形式出现，看上去很不符合标准，或者可能会出现如:%64%b3%e8%ae%ar%e6%ba%a7%e5%9.html 类似乱码的显示。因此需要在编辑文章时，标题下面固定链接项，点击编辑，用拼音或英文输入文章标题。 然后把wordpress目录下的index.php 和 .htaccess文件复制一份到根目录下，.htaccess 是隐藏文件，可以使用ls -all。将其显示出来。注意是复制文件，原来目录下还存在。 123cd /var/www/html/wordpress/cp index.php /var/www/html/cp .htaccess /var/www/html/ 然后使用vim修改.htaccess文件的内容为下图所示。（默认文件如果就是如此则跳过该步骤） 修改index.php文件，因为index.php文件是wordpress下index.php的复制品，因此文件内部的require那一行的值当对于当前目录，是不正确的。同样使用vim编辑该文件，把require那一行路径，修改成下图那样。 此时再输入IP，看到还是It works界面，那是因为安装apache时，我们看到的It works界面其实是根目录下的index.html。当index.html 和 index.php同时存在时，默认还是打开index.html，所以应该把index.html移出该目录。我们把它移出到其他目录就行。 然后可能会产生下一个问题，设置固定链接后，文章页会404解决方法如下： 1sudo vi /etc/apache2/apache2.conf 把 AllowOverride None 改为 AllowOverride ALL 注意有两处要改，然后操作一下 12sudo a2enmod rewritesudo /etc/init.d/apache2 restar 刷新一下应该就能正常打开文章了。 主页样式修改 页尾和功能模块里的链接如果觉得碍眼，可以去除。 删除页尾“自豪地使用WordPress”字样 如果是通过函数生成页尾的主题，一般在模板函数那里修改，查找 “Proudly powered by” 的字样删掉就ok。 1&lt;a href=“&lt;?php echo esc\\_url( \\_\\_( ‘http://wordpress.org/’, ‘twentyeleven’ )); ?&gt;” title=“&lt;?php esc\\_attr\\_e(‘SemanticPersonalPublishing Platform’, ‘twentyeleven’ ); ?&gt;” rel=“generator”&gt;&lt;?php printf( __( ‘Proudly powered by%s’,‘twentyeleven’ ), ‘WordPress’ ); ?&gt;&lt;/a&gt; 删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”打开组件文件夹：wp-include/widgets/class-wp-widget-meta.php 找到代码段删除即可。 1234&lt;!\\-\\- 屏蔽 RSS 功能&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'rss2\\_url' )); ?&gt;\"&gt;&lt;?php \\_e('Entries &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'comments\\_rss2\\_url' )); ?&gt;\"&gt;&lt;?php _e('Comments &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;--&gt;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"性冷淡商务风：深圳龙华希尔顿逸林酒店","slug":"doubletree-longhua","date":"2017-05-16T16:00:50.000Z","updated":"2019-03-22T12:14:27.248Z","comments":true,"path":"p/doubletree-longhua/","link":"","permalink":"https://paaatrick.com/p/doubletree-longhua/","excerpt":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。","text":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。 一进大堂就是典型的 DoubleTree 性冷淡风格，米白色大理石为主的装修风格使原本较小的大堂显得大气，前台人手不够，客人多时要排队 CI/CO，上酒廊 Check-in 就更是要等很久了。 酒店被设计在这栋楼底部十几层，上半部分是写字楼，似乎业主不太重视酒店。 这次入住时房态紧张，只给升一级到12楼的园景房，虽然没升级到行政房不过也给了行政待遇。 DoubleTree 标志性的热曲奇饼，每位顾客入住时都给两份，很好吃，路过前台时可以再要几块。 因为是新开业的酒店，硬件水准在同品牌中数一数二，客房面积48平方起步也没什么问题，套房楼层据说被某剧组包了几个月，因此没能升级套房挺可惜的。 逸林标配单人浴缸，卫生间干湿分离，瑰珀翠（Crabtree &amp; Evelyn）的备品味道一般，还是更喜欢彼得罗夫（Peter Thomas Roth）的热情果味。 窗外正对龙华文化广场，也是新建的，晚上有大批广场舞大妈，幸好玻璃隔音性能不错，问题是晚上有治安的单车持续闪烁红蓝灯光，穿透力极强，不拉上遮光窗帘要被闪瞎眼。 床头音响支持直接插 iPhone 播放，插座自带USB也是这几年新开酒店的标配了。欢迎水果略显小气，进门的柜子另有玄机，水壶茶杯和小冰箱都藏在里面。 行政酒廊的 Happy Hour 从17点到19点，菜品十分丰富，热菜、甜品很多，当作晚餐完全没有问题。 酒店健身房还没装修好，把酒廊对面的一间套房改造成了一个临时健身房，所以面积很小，设备也不够多，来几个老外就占满了。室外泳池也要到17年5月底才开放。 回到房间发现已经开好了夜床，可能是看到一下子把两瓶水喝完了，于是又补充了六瓶😂而且很贴心地在床上放了张明日天气预报。 酒店的主餐厅名为 『OPEN | “開”全日餐厅』，然而晚上只营业到22点，并没有通宵开放😑 早餐看似丰富，实际出品一般，蛋卷和鸡肉肠还没有希尔顿花园的好吃。不过餐厅环境确实不错，适合平时晚上来吃自助餐。 这间 DoubleTree 最近几个月都不放基础房了，可能确实是商务客比较多吧， 10000分入住虽然没有华东一堆5000分 DoubleTree 那么白菜价，但毕竟地处深圳龙华腹地，性价比非常高，实属希尔顿保级优选。 原文始发于微信公众号（派大星星星星）：性冷淡商务风：深圳龙华希尔顿逸林酒店","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Hotel","slug":"Hotel","permalink":"https://paaatrick.com/tags/Hotel/"}]},{"title":"宜家 | 一个顺便卖卖家具的饭堂","slug":"ikea-canteen","date":"2015-12-16T16:00:50.000Z","updated":"2019-03-22T12:14:27.245Z","comments":true,"path":"p/ikea-canteen/","link":"","permalink":"https://paaatrick.com/p/ikea-canteen/","excerpt":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛","text":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛 然而事实上并不是这样的 宜家不只是卖家具 也卖非常多零碎玩意 很适合买来充实宿舍 但更重要的是它的餐厅 一个室友说 “宜家就是个顺便卖家具的食堂” 这话不假 这个餐厅不只是周末人满为患 即便是工作日也要找座位找很久 这还是宜家坐落在没有地铁经过的郊区的前提下 显得更为难得 ▲餐厅门口菜单 餐厅不算太大 菜单也很简单 主菜也就瑞典肉圆 蔬菜丸 肉酱面 三文鱼 西冷牛扒 牛肉饭等 最赞的就是瑞典肉圆了 不同于汕头牛肉丸爽口 弹性 有嚼劲 宜家的瑞典肉圆口感细腻 用料丰富 以猪肉和牛肉混合搅碎 加入牛奶 面包糠 切碎的洋葱 马铃薯粉或燕麦片 然后再加上白胡椒 盐 五香粉或肉桂等香料调味 搓匀后捏成球形 食用时配以肉酱 土豆泥 果酱以及一枚瑞典国旗 令人食指大动 西冷牛扒出品还算可以 虽然跟专门做牛扒的餐厅相比差距不小 但考虑到三十多的售价也能理解 还是值这个价的 烤三文鱼配通心粉 份量十足 不到三十块 价格感人 奥尔良鸡腿 表皮烤的焦焦的 肉质多汁嫩滑 跟肉丸一样也是必点 冷盘菜 香草三文鱼 酸黄瓜酱不会掩盖三文鱼的鲜美 反而相得益彰美味可口 宜家物价让人有种回到十年前的感觉 在深圳物价飞涨都快赶上香港的年代 还有这么个出品优良又便宜的餐厅实属不易 如果不是因为路途遥远交通不便利真的就成饭堂了 ▲取菜窗口超像饭堂 说是饭堂的另一个原因 顾客吃完后需要自己把餐盘放进回收车里 大大减少清洁阿姨工作量 ▲会员卡颜值颇高 记得办一张宜家的会员卡 在入口和收银台前都有免费申请的电脑 填完资料直接就吐卡出来了 工作日凭会员卡可以在餐厅免费喝咖啡 无限续杯的喔 而且很多单品都有会员优惠 比如这个两块九的杯子 新会员可以一块钱购买 值得一提的是毛巾和门垫 毛巾质量很好 不会掉毛 门垫价格感人 可以屯多几张在宿舍 脏了直接换一个 在收银台出来的地方还有一个小食档 五块钱的热狗套餐可以无限续杯 最近饮料都换成了相比可乐含糖量减半的北欧风味果味饮料 不过感觉还是以前的蔓越莓果汁好喝 还有就是十块三串的墨鱼丸 真心赞赞赞赞赞 外焦里嫩弹牙可口 墨鱼味十足 买买买后吃上一份墨鱼丸真是酸爽 还有同样十块三串的烤肠 味道跟乐凯撒的烤肠差不多 因为量不多 晚上七八点后可能就卖完了 同样强力推荐 见到了赶紧买三串 小食档旁边还有专门卖瑞典特产的超市 如果肉丸或者三文鱼吃的不过瘾还能买冷冻的回去自己煮 阻挡宜家成为饭堂的最大因素还是地理位置不好 公交非常不便利 只能自驾或者打车前往 不过不塞车的话从桂庙过去十分钟就能到 所以闲暇之余还是可以去吃餐饭的 原文始发于微信公众号（派大星星星星）：宜家 | 一个顺便卖卖家具的饭堂","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]},{"title":"一蘭拉面","slug":"ichiran-ramen","date":"2015-11-17T16:00:50.000Z","updated":"2019-03-22T12:14:27.244Z","comments":true,"path":"p/ichiran-ramen/","link":"","permalink":"https://paaatrick.com/p/ichiran-ramen/","excerpt":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。","text":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。 ▲座位都是一个个隔间 年初的时候，一兰除了日本本土外就只有铜锣湾一家分店，港岛线铜锣湾站C出口走5分钟谢斐道440号门面便是。店铺不算大，目测只能容纳50人，天黑了之后一直到凌晨三四点都要排队，22点左右高峰期甚至要排一个钟的队，不过为了吃上一碗一兰拉面，排队久一点也值得。 ▲铜锣湾店排队排出了店面 ▲空余座位展示，每个绿色格子代表一个座位 ▲只有一款面的菜单 排队快到的时候店员会给单你让你圈出偏好，我除了硬度喜欢偏硬一些外其他都是普通。偏硬是因为咬起来有口感。一碗89块港币的拉面，精华在于汤底，浓香而不腻，实打实用豚骨熬制，不加味精。吃完面后如果不喝汤就太浪费了。 ▲1/2倍辣 因为还是学生，钱不多，所以很少追加面底、温泉蛋、叉烧或者波子汽水。不过温泉蛋是真心好吃，建议尾巴们去的话一定要点一份。 秘制酱汁确实挺辣的，有一次被怂恿写了5倍辣，吃完整个人都不好了，当晚睡觉都睡不好。当然主要是因为我不太能吃辣，无辣不欢的尾巴可以试试20倍辣，很酸爽[doge] ▲5倍辣 店面是单人隔间，每个位置都有冷水水龙头，就算再冷的天也是冷水。网上的解释是 冰水的作用在於吃拉面时缓和浓厚的味道，同时有助口腔降温加快吃面速度，因为面太热而吃得慢，面浸汤糊烂的情况只会越来越严重。 冰水是多年来日式拉面的传统，春夏秋冬也不改。博主曾在下雪日子在拉面店外排队，店员会为等待的人送上热茶，但去到店内还是冰水。 希望大家不要因為气温10度时拉面店内送上冰水就破口大骂或上网劣评，人家日本人下雪时都未投诉。理解这原因后仍想要热水的话，向店员礼貌地要求就是了。 ▲每个座位上都有首次来店顾客指南，中英日各一份 今年年中的时候，一兰在尖沙咀棉登径8号负一楼开了第二家分店。不知道什么原因，很多地图上都还没有标记出来，尖沙咀N4出口出来就是了。 ▲高德地图 ▲尖沙咀店入口，店铺在负一楼 可能是因为在铜锣湾的第一家海外分店尝到了甜头，这家新分店面积很大，而且出现了一兰屋台，就是普通餐厅的座椅区，但我还是喜欢隔间多一点，毕竟隔间是一兰的特色，坐屋台的话没有感觉。 ▲尖沙咀店一兰屋台 ▲一兰方便面 一兰方便面，四五月份刚推出的时候有买单满200HKD送一个的活动，回来宿舍泡了一下发现挺一般的，跟店里吃的差距太大，不知道是方便面的问题还是我泡面方法不当[摊手]原价是198HKD五包，据说买一套的话里面会有特殊配料 ▲泡出来的效果，凭良心讲确实比合味道之类的好吃一些，但还不至于太好吃，不值那个价。 ▲方便面海报 ▲收银台 ▲收银台后面的展柜 月初去吃的时候发现账单多了一项额外10%的服务费，以前都没见过，不知道是最近才开始收的还是因为尖沙咀店比较大要额外收费。付款支持现金、八达通和银联卡，我预计不用太久，支付宝就会来插一脚，进一步方便大陆游客在香港游玩。 ▲尖沙咀店内海报 还没读大学的时候在广州住，每次去正佳和中华基本上都是吃博多一幸舍。博多刚进驻广州第一次吃的时候震惊了，怎么会有这么好吃的面，从此再也没吃过味千公仔面。 然而上大学后，某次安利别人博多时被反安利了一兰，这才发觉山外有山。 ▲铜锣湾店门面 一兰没有博多一幸舍的喧闹环境，店员们不会热血地齐声用日语喊欢迎光临，只会在隔间后面端面上来时说一声慢用（不会日语，猜的）然后落下帘子。店里如果没有小孩的话一般都挺安静。 另外不同于博多丰富的菜单，一兰只有一款面（好像最近新推出了一款沾面，不太记得了）。 ▲基友吃得正欢 在我有限的经历中，一兰拉面在我吃过的日本拉面中算是最好吃的了，一兰以其独特的隔间设计，只做一款面的坚持，极致浓香的汤底，口感细腻的面底赢得了大众的喜爱。有时候我嘴馋了也不怕劳累，专门从深圳湾过关搭巴士到天水围转港铁到尖沙咀来吃个面，也算是一兰真粉了。 大家如果去一兰，一定要预留多一些时间用来排队，以免耽误行程。[doge] 原文始发于微信公众号（派大星星星星）：一蘭拉面 2019.01更新 — 日本的一蘭拉面 2018年夏天去大阪和东京晃悠了一圈，路过不少一兰。 大阪 ▲大阪也超多人 ▲自助机器先付后食，这种机器是真的🐂🍺 ▲自助机出的票 ▲出品稳定，跟香港的几乎没区别 东京▲还是自助机，依然人多得一批 ▲还是一样的味道 ▲一样的抹茶豆腐","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]}]}