<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode做题笔记—DP动态规划相关题目</title>
      <link href="/2019-05-15-leecode-dynamic-programming/"/>
      <url>/2019-05-15-leecode-dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>有关动态规划 Dynamic Programming 的做题笔记，Python实现</p><h2 id="70-爬楼梯-Climbing-Stairs"><a href="#70-爬楼梯-Climbing-Stairs" class="headerlink" title="70. 爬楼梯 Climbing Stairs"></a>70. 爬楼梯 Climbing Stairs</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCodeCN 第70题链接</a></p><p>第一种方法：递归，显然是个斐波那契数列，时间复杂度 $O(2^n)$很高，这样没法通过LeetCode，参考 @wikizero 的解法可以加个LRU缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from functools import lru_cache</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>        </span><br><span class="line">    <span class="comment"># @lru_cache(10**8)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n - <span class="number">1</span>) + self.climbStairs(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>第二种方法：动态规划，用数组记录每个台阶的所有走法个数，时间复杂度降为 $O(n)$</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><p>第三种方法：动态规划，由于只需要返回最后一步的所有走法个数，不需要数组记录过程，利用Python的同时赋值特性，只需两个变量就行，空间复杂度降为 $O(1)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        one = two = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            one, two = one + two, one</span><br><span class="line">        <span class="keyword">return</span> one</span><br></pre></td></tr></table></figure><h2 id="120-三角形最小路径和-Triangle"><a href="#120-三角形最小路径和-Triangle" class="headerlink" title="120. 三角形最小路径和 Triangle"></a>120. 三角形最小路径和 Triangle</h2><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">LeetCodeCN 第120题链接</a></p><p>第一种方法：递归，时间复杂度<code>O(2^n)</code>，LeetCode会超时过不了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        self.tri = triangle</span><br><span class="line">        self.path = []</span><br><span class="line">        self.helper(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min(self.path)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, j, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= len(self.tri):</span><br><span class="line">            self.path.append(res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res += self.tri[i][j]</span><br><span class="line">        self.helper(i+<span class="number">1</span>, j, res)</span><br><span class="line">        self.helper(i+<span class="number">1</span>, j+<span class="number">1</span>, res)</span><br></pre></td></tr></table></figure><p>第二种方法：动态规划，新建个二维数组<code>mini</code>，定义<code>mini[i][j]</code>为从三角形底部到<code>[i][j]</code>的最小路径和，递推公式<code>mini[i][j] = triangle[i][j] + min(mini[i+1][j], mini[i+1][j+1])</code>即本身节点的值加上下一层<code>[i+1]</code>里相邻两个节点<code>mini</code>的最小值，首先把三角形最后一层赋值给<code>mini</code>的最后一层，然后两个循环，最后得到<code>mini[0][0]</code>三角形顶部节点，时间复杂度<code>O(n^2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        lens = len(triangle)</span><br><span class="line">        mini = [[<span class="number">0</span>]*lens <span class="keyword">for</span> _ <span class="keyword">in</span> range(lens)]</span><br><span class="line">        mini[lens<span class="number">-1</span>] = triangle[lens<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lens<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                mini[i][j] = triangle[i][j] + min(mini[i+<span class="number">1</span>][j], mini[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> mini[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第三种方法：在第二种方法的基础上，<code>mini</code>只需一维数组即可，更新自身</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        mini = triangle[len(triangle)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                mini[j] = triangle[i][j] + min(mini[j], mini[j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> mini[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第四种方法：在第二种方法的基础上，直接修改三角形数组的值，空间复杂度为<code>O(1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                triangle[i][j] += min(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="152-乘积最大子序列-Maximum-Product-Subarray"><a href="#152-乘积最大子序列-Maximum-Product-Subarray" class="headerlink" title="152. 乘积最大子序列 Maximum Product Subarray"></a>152. 乘积最大子序列 Maximum Product Subarray</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCodeCN 第152题链接</a></p><p>第一种方法：DP动态规划，创建二维数组<code>dp</code>，<code>dp[i][0]</code>存放正数最大值, <code>dp[i][1]</code>存放最小值即负数的最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dp:</span><br><span class="line">            result.append(j[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(result)</span><br></pre></td></tr></table></figure><p>第二种方法：在第一种方法的基础上，用一维滚动数组<code>dp</code>，每次循环交替x和y为0和1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], res = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            x, y = i &amp; <span class="number">1</span>, (i - <span class="number">1</span>) &amp; <span class="number">1</span></span><br><span class="line">            dp[x][<span class="number">0</span>] = max(dp[y][<span class="number">0</span>]*nums[i], dp[y][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            dp[x][<span class="number">1</span>] = min(dp[y][<span class="number">0</span>]*nums[i], dp[y][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            res = max(res, dp[x][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="买卖股票最佳时机系列"><a href="#买卖股票最佳时机系列" class="headerlink" title="买卖股票最佳时机系列"></a>买卖股票最佳时机系列</h1><h2 id="121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock"></a>121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCodeCN 第121题链接</a></p><p>第一种方法：由于一次交易操作，可以通过记录最小价格，计算最大利润的方式，空间换时间，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        res, low = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">            low = min(prices[i], low)</span><br><span class="line">            res = max(res, prices[i] - low)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>第二种方法：DP动态规划，与下面122题相比，由于只能一次交易操作，第<code>i</code>天的状态就不止“不持有”和“持有”两种状态，而是“未持有”、“持有”、“卖出”三种，并需要一个变量存储最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 生成数组, 然后给初始状态赋值</span></span><br><span class="line">        dp, res = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(prices))], <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># dp[i][0] 第i天 一直没有股票的利润</span></span><br><span class="line">            <span class="comment"># dp[i][1] 第i天 当前有股票的利润 取 max(前面有股票今天不卖, 前面没股票今天买入)</span></span><br><span class="line">            <span class="comment"># dp[i][2] 第i天 之前买入现在卖了的利润(前面有股票今天卖出)</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            res = max(res, dp[i][<span class="number">0</span>], dp[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II"></a>122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LeetCodeCN 第122题链接</a></p><p>第一种方法：深度优先搜索，时间复杂度<code>O(2^n)</code>，这个通过不了LeetCode，不过能work，测试了多组测试样例是正确的</p><!-- more --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.prices = prices</span><br><span class="line">        self.profit = []</span><br><span class="line">        self.helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(self.profit)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># have 0:未持有  1:持有</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, have, profit)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(self.prices):</span><br><span class="line">            self.profit.append(profit)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> have: <span class="comment"># 如果持有中</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit + self.prices[i]) <span class="comment"># 卖出</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果未持有</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit - self.prices[i]) <span class="comment"># 买入</span></span><br></pre></td></tr></table></figure><p>第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                ans += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>第三种方法：标准二维DP动态规划，第<code>i</code>天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III"></a>123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">LeetCodeCN 第123题链接</a></p><p>第一种方法：标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。与下面188题买卖股票4一样的代码，把交易k次定义为2次。当然也可以把内层的for循环拆出来，分别列出交易0次、1次、2次的状态转移方程即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][j][0]表示第i天交易了j次时不持有股票, dp[i][j][1]表示第i天交易了j次时持有股票</span></span><br><span class="line">        <span class="comment"># 定义卖出股票时交易次数加1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：用变量而不是多维数组保存迭代的值，优点是省内存空间，缺点是不是标准DP，没法泛化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        buy1, sell1, buy2, sell2 = -prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            buy1 = max(buy1,-prices[i])<span class="comment">#用负值统一变量</span></span><br><span class="line">            sell1 = max(sell1,buy1 + prices[i])<span class="comment">#sell1为 0~i(含)天股市中买卖一次的最优利润</span></span><br><span class="line">            buy2 = max(buy2,sell1 - prices[i])<span class="comment">#仅当＞0才会更新，保证 第二次买入不会与第一次卖出为同一天。而sell1为历史记录保证第二次买入比第一次卖出晚。</span></span><br><span class="line">            sell2 = max(sell2,buy2 + prices[i])<span class="comment">#若第二轮买卖为同一天，则不会更新。此操作自然保证sell2为买卖至多两次的最优利润。</span></span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV"></a>188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">LeetCodeCN 第188题链接</a></p><p>标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。</p><p>首先初始化三维数组，填充第1天操作j次的没买或买了的情况的初始值，没买就是<code>0</code>，第一天就买入即<code>-prices[0]</code>。这里定义卖出操作时交易次数加<code>1</code></p><p>然后是状态转移方程，下面描述的<code>i, j</code>都大于<code>0</code></p><p>「第<code>i</code>天交易次数<code>0</code>不持有股票」的情况只能来自「第<code>i-1</code>天交易次数<code>0</code>不持有股票」；</p><p>「第<code>i</code>天交易<code>j</code>次不持有股票」的状态可以来自「第<code>i-1</code>天交易<code>j</code>次不持有股票」或者「第<code>i-1</code>天交易<code>j-1</code>次持有股票」(即今天卖出股票，然后交易次数+1)；</p><p>「第<code>i</code>天交易<code>j</code>次持有股票」的状态可以来自「第<code>i-1</code>天交易<code>j</code>次持有股票」或者「第<code>i-1</code>天交易<code>j</code>次不持有股票」(即今天买入股票，因为是买入操作所以交易次数不变)</p><p>最后对于这题LeetCode的测试样例里有超大k值的情况，退化成122题不限次数的操作，可以用贪心解决或者直接替换k值为数组长度的一半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment"># 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n<span class="number">-1</span>][m][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理k过大导致超时的问题，用贪心解决</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown"></a>309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">LeetCodeCN 第309题链接</a></p><p>第一种方法：标准DP动态规划，三个维度，第一维表示天，第二维表示是否处于冷冻期，第三维表示是否持有股票</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0][0]第一维表示第i天, 第二维用0,1表示是否处于冷冻期, 第三维用0,1表示是否持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：优化版的动态规划，用两个维度处理，第一维表示天，第二维用0表示未持有，1表示持有股票中，2表示处于冷冻期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天未持有, dp[i][1]表示持有股票, dp[i][2]表示前一天刚卖出今天处于冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="300-最长上升子序列-Longest-Increasing-Subsequence"><a href="#300-最长上升子序列-Longest-Increasing-Subsequence" class="headerlink" title="300. 最长上升子序列 Longest Increasing Subsequence"></a>300. 最长上升子序列 Longest Increasing Subsequence</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCodeCN 第300题链接</a></p><p>DP动态规划，定义状态<code>dp[i]</code>为以<code>nums[i]</code>为结尾且必须包含<code>nums[i]</code>本身的最长上升子序列的长度。两个嵌套的循环，状态转移方程<code>dp[i] = max(dp[i], dp[j] + 1)</code>即在内层循环内通过比较<code>dp[j]</code>来不断迭代<code>dp[i]</code>，找到前面最大的一个<code>dp</code>值然后加1。最后<code>dp</code>数组的最大值就是问题的解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换-Coin-Change"><a href="#322-零钱兑换-Coin-Change" class="headerlink" title="322. 零钱兑换 Coin Change"></a>322. 零钱兑换 Coin Change</h2><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LeetCodeCN 第322题链接</a></p><p>第一种方法：DFS深度优先搜索，暴力操作，LeetCode会超时过不去<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        self.coins = sorted(coins, reverse=<span class="literal">True</span>)</span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.coins:</span><br><span class="line">            self.dfs(amount, i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.res:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> min(self.res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, amount, num, count)</span>:</span></span><br><span class="line">        last = amount - num</span><br><span class="line">        <span class="keyword">if</span> last &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> last:</span><br><span class="line">            self.res.append(count)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.coins:</span><br><span class="line">            self.dfs(last, i, count + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>第二种方法：DP动态规划，定义状态<code>dp[i]</code>为拼凑数额<code>i</code>最少所需的硬币数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> i - c &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-c] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] &lt;= amount <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—位运算相关题目</title>
      <link href="/2019-05-13-leetcode-bitwise/"/>
      <url>/2019-05-13-leetcode-bitwise/</url>
      
        <content type="html"><![CDATA[<p>有关位运算的做题笔记，Python实现</p><h2 id="191-位1的个数-Number-of-1-Bits"><a href="#191-位1的个数-Number-of-1-Bits" class="headerlink" title="191. 位1的个数 Number of 1 Bits"></a>191. 位1的个数 Number of 1 Bits</h2><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCodeCN 第191题链接</a></p><p>第一种方法：遍历所有二进制位，通过取模<code>n%2</code>或者与运算<code>n&amp;1</code>判断尾数是否为1，然后把n右移一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><a id="more"></a><p>第二种方法：通过<code>n &amp; (n - 1)</code>直接摘掉最后一位的1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="231-2的幂-Power-of-Two"><a href="#231-2的幂-Power-of-Two" class="headerlink" title="231. 2的幂 Power of Two"></a>231. 2的幂 Power of Two</h2><p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">LeetCodeCN 第231题链接</a></p><p>先排除负数和0，由于2的幂的二进制只有第一位是1，通过<code>n &amp; (n - 1)</code>直接摘掉最后一位的1，如果摘掉后为0即符合条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> n &amp; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="338-比特位计数-Counting-Bits"><a href="#338-比特位计数-Counting-Bits" class="headerlink" title="338. 比特位计数 Counting Bits"></a>338. 比特位计数 Counting Bits</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCodeCN 第338题链接</a></p><p>第一种方法：遍历，每次分别计算一次比特位，时间复杂度为n乘以每个数的1位个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i = i &amp; (i - <span class="number">1</span>)</span><br><span class="line">            result.append(count)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>第二种方法：用一个递推式子<code>count[i] = count[i&amp;(i-1)] + 1</code>，原理是<code>i&amp;(i-1)</code>的1的个数总是比<code>i</code>少1，同时<code>i&amp;(i-1)</code>这个数肯定比<code>i</code>小，所以预先是算过的，这样时间复杂度为<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        result = [<span class="number">0</span>] * (num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num+<span class="number">1</span>):</span><br><span class="line">            result[i] = result[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—广度优先搜索、深度优先搜索、剪枝相关题目</title>
      <link href="/2019-05-09-leetcode-bfs-dfs-pruning/"/>
      <url>/2019-05-09-leetcode-bfs-dfs-pruning/</url>
      
        <content type="html"><![CDATA[<p>有关BFS（广度优先搜索）与DFS（深度优先搜索）的做题笔记，Python实现</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层次遍历-Binary-Tree-Level-Order-Traversal"><a href="#102-二叉树的层次遍历-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. 二叉树的层次遍历 Binary Tree Level Order Traversal"></a>102. 二叉树的层次遍历 Binary Tree Level Order Traversal</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCodeCN 第102题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，注意<code>range(len(queue))</code>使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不是树而是图的话要记录一下访问过的节点，避免重复访问</span></span><br><span class="line">        <span class="comment"># visited = set(root)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = len(queue)</span><br><span class="line">            current_level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                current_level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            result.append(current_level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>记号把节点放入对应层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.result = []</span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.result) &lt; level + <span class="number">1</span>:</span><br><span class="line">            self.result.append([])</span><br><span class="line">        self.result[level].append(node.val)</span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度-Maximum-Depth-of-Binary-Tree"><a href="#104-二叉树的最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. 二叉树的最大深度 Maximum Depth of Binary Tree"></a>104. 二叉树的最大深度 Maximum Depth of Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第104题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，<code>range(len(queue))</code>使只遍历当前的层，每次大循环<code>ans</code>加1。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>标记当前层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ans &lt; level + <span class="number">1</span>:</span><br><span class="line">            self.ans = level + <span class="number">1</span></span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第三种方法：DFS+分治，虽然代码简洁但耗时比上面两种方法都久</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度-Minimum-Depth-of-Binary-Tree"><a href="#111-二叉树的最小深度-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. 二叉树的最小深度 Minimum Depth of Binary Tree"></a>111. 二叉树的最小深度 Minimum Depth of Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第111题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，<code>range(len(queue))</code>使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br></pre></td></tr></table></figure><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>标记当前层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.ans = float(<span class="string">'inf'</span>)</span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ans &gt; level + <span class="number">1</span>:</span><br><span class="line">                self.ans = level + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="22-括号生成-Generate-Parentheses"><a href="#22-括号生成-Generate-Parentheses" class="headerlink" title="22. 括号生成 Generate Parentheses"></a>22. 括号生成 Generate Parentheses</h2><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCodeCN 第22题链接</a></p><p>DFS+剪枝，利用左括号与右括号分别已用的参数，当两个参数都为<code>n</code>时即填完一个结果添加进结果数组，精髓在于<code>if left_used &gt; right_used</code>，只有在右括号少于左括号时才能填充右括号，保证输出的结果是合法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.helper(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left_used: int, right_used: int, n: int, result: str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left_used == n <span class="keyword">and</span> right_used == n:</span><br><span class="line">            self.ans.append(result)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left_used &lt; n:</span><br><span class="line">            self.helper(left_used + <span class="number">1</span>, right_used, n, result + <span class="string">'('</span>)</span><br><span class="line">        <span class="keyword">if</span> left_used &gt; right_used <span class="keyword">and</span> right_used &lt; n:</span><br><span class="line">            self.helper(left_used, right_used + <span class="number">1</span>, n, result + <span class="string">')'</span>)</span><br></pre></td></tr></table></figure><h2 id="51-N皇后-N-Queens-52-N皇后-II-N-Queens-II"><a href="#51-N皇后-N-Queens-52-N皇后-II-N-Queens-II" class="headerlink" title="51. N皇后 N-Queens / 52. N皇后 II N-Queens II"></a>51. N皇后 N-Queens / 52. N皇后 II N-Queens II</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">LeetCodeCN 第51题链接</a><br><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">LeetCodeCN 第52题链接</a></p><p>用三个<code>set()</code>记录矩阵内因放入皇后而封住的格子，<code>self.col</code>是列，<code>self.sum</code>是<code>row+col</code>表示的 ‘/‘ 方向 <code>self.dif</code>是<code>row-col</code>表示的 ‘\‘ 方向。</p><p>用深度优先搜索方法，逐行递归下去，递归终止条件是行数加到<code>n</code>时，此时即生成了一种解决方案，放入结果数组。</p><p>每次递归内迭代列<code>col</code>检查这个点位是否能放下，能放下的话把自身点位加入三个<code>set</code>内，继续下个递归，参数<code>state</code>数组<code>append</code>这一行的列值 <code>col</code>。</p><p>递归函数后记得清除因放入自己的影响即三个<code>set</code>。</p><p>最后为51题生成结果图的函数<code>_gen</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.col = set()</span><br><span class="line">        self.sum = set()</span><br><span class="line">        self.dif = set()</span><br><span class="line">        self._dfs(n, <span class="number">0</span>, [])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 51题: 输出点阵图</span></span><br><span class="line">        <span class="keyword">return</span> self._gen(n)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 52题: 输出结果数量</span></span><br><span class="line">        <span class="comment"># return len(self.result)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, n, row, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= n:</span><br><span class="line">            self.result.append(state)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> self.col <span class="keyword">or</span> row+col <span class="keyword">in</span> self.sum <span class="keyword">or</span> row-col <span class="keyword">in</span> self.dif:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.col.add(col)</span><br><span class="line">            self.sum.add(row + col)</span><br><span class="line">            self.dif.add(row - col)</span><br><span class="line">            </span><br><span class="line">            self._dfs(n, row + <span class="number">1</span>, state + [col])</span><br><span class="line">            </span><br><span class="line">            self.col.remove(col)</span><br><span class="line">            self.sum.remove(row + col)</span><br><span class="line">            self.dif.remove(row - col)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_gen</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> self.result:</span><br><span class="line">            graph = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">                graph.append(<span class="string">'.'</span>*i + <span class="string">'Q'</span> + <span class="string">'.'</span>*(n-i<span class="number">-1</span>))</span><br><span class="line">            result.append(graph)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="37-解数独-Sudoku-Solver"><a href="#37-解数独-Sudoku-Solver" class="headerlink" title="37. 解数独 Sudoku Solver"></a>37. 解数独 Sudoku Solver</h2><p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCodeCN 第37题链接</a></p><p>DFS朴素解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> board <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.solve(board)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]:</span><br><span class="line">                        <span class="keyword">if</span> self.isValid(board, i, j, c):</span><br><span class="line">                            board[i][j] = c</span><br><span class="line">                            <span class="keyword">if</span> self.solve(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, board, row, col, c)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][i] != <span class="string">'.'</span> <span class="keyword">and</span> board[row][i] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col] != <span class="string">'.'</span> <span class="keyword">and</span> board[i][col] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] != <span class="string">'.'</span> <span class="keyword">and</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="36-有效的数独-Valid-Sudoku"><a href="#36-有效的数独-Valid-Sudoku" class="headerlink" title="36. 有效的数独 Valid Sudoku"></a>36. 有效的数独 Valid Sudoku</h2><p>第一种方法：利用<code>collections</code>的<code>defaultdict</code>数据结构记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="keyword">as</span> cl</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.row, self.col, self.box = cl.defaultdict(set), cl.defaultdict(set), cl.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.row[r] <span class="keyword">and</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.col[c] <span class="keyword">and</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.box[(r//<span class="number">3</span>, c//<span class="number">3</span>)]:</span><br><span class="line">                        self.row[r].add(board[r][c])</span><br><span class="line">                        self.col[c].add(board[r][c])</span><br><span class="line">                        self.box[(r//<span class="number">3</span>, c//<span class="number">3</span>)].add(board[r][c])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>第二种方法：不用额外空间，直接循环检测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.isValid(board, r, c, board[r][c]):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, board, row, col, c)</span> -&gt; bool:</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][i] != <span class="string">'.'</span> <span class="keyword">and</span> board[row][i] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col] != <span class="string">'.'</span> <span class="keyword">and</span> board[i][col] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] != <span class="string">'.'</span> <span class="keyword">and</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        board[row][col] = c    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="69-x-的平方根-Sqrt-x"><a href="#69-x-的平方根-Sqrt-x" class="headerlink" title="69. x 的平方根  Sqrt(x)"></a>69. x 的平方根  Sqrt(x)</h2><p>第二种方法：牛顿迭代法，$X_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}$，这里的$f(x_n)$是$x^2 - y_0$，即得迭代公式$x_{n+1} = (x_n + \frac{y_0}{x_n}) / 2 $<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span>        </span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">while</span> r &gt; x / r:</span><br><span class="line">            r = (r + x / r)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> int(r)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—买卖股票的最佳时机系列题目</title>
      <link href="/2019-05-07-leetcode-best-time-to-buy-and-sell-stock-series/"/>
      <url>/2019-05-07-leetcode-best-time-to-buy-and-sell-stock-series/</url>
      
        <content type="html"><![CDATA[<p>有关买卖股票最佳时机系列做题笔记，Python实现</p><h2 id="121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock"></a>121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCodeCN 第121题链接</a></p><p>第一种方法：由于一次交易操作，可以通过记录最小价格，计算最大利润的方式，空间换时间，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        res, low = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">            low = min(prices[i], low)</span><br><span class="line">            res = max(res, prices[i] - low)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>第二种方法：DP动态规划，与下面122题相比，由于只能一次交易操作，第<code>i</code>天的状态就不止“不持有”和“持有”两种状态，而是“未持有”、“持有”、“卖出”三种，并需要一个变量存储最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 生成数组, 然后给初始状态赋值</span></span><br><span class="line">        dp, res = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(prices))], <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># dp[i][0] 第i天 一直没有股票的利润</span></span><br><span class="line">            <span class="comment"># dp[i][1] 第i天 当前有股票的利润 取 max(前面有股票今天不卖, 前面没股票今天买入)</span></span><br><span class="line">            <span class="comment"># dp[i][2] 第i天 之前买入现在卖了的利润(前面有股票今天卖出)</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            res = max(res, dp[i][<span class="number">0</span>], dp[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II"></a>122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LeetCodeCN 第122题链接</a></p><p>第一种方法：深度优先搜索，时间复杂度<code>O(2^n)</code>，这个通过不了LeetCode，不过能work，测试了多组测试样例是正确的</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.prices = prices</span><br><span class="line">        self.profit = []</span><br><span class="line">        self.helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(self.profit)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># have 0:未持有  1:持有</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, have, profit)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(self.prices):</span><br><span class="line">            self.profit.append(profit)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> have: <span class="comment"># 如果持有中</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit + self.prices[i]) <span class="comment"># 卖出</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果未持有</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit - self.prices[i]) <span class="comment"># 买入</span></span><br></pre></td></tr></table></figure><p>第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                ans += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>第三种方法：标准二维DP动态规划，第<code>i</code>天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III"></a>123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III</h2><p>第一种方法：标准的三维DP动态规划，与下面188题买卖股票4一样的代码，把交易k次改为2次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][j][0]表示第i天交易了j次时不持有股票, dp[i][j][1]表示第i天交易了j次时持有股票</span></span><br><span class="line">        <span class="comment"># 定义卖出股票时交易次数加1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：用变量而不是多维数组保存迭代的值，优点是省内存空间，缺点是不是标准DP，没法泛化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        buy1, sell1, buy2, sell2 = -prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            buy1 = max(buy1,-prices[i])<span class="comment">#用负值统一变量</span></span><br><span class="line">            sell1 = max(sell1,buy1 + prices[i])<span class="comment">#sell1为 0~i(含)天股市中买卖一次的最优利润</span></span><br><span class="line">            buy2 = max(buy2,sell1 - prices[i])<span class="comment">#仅当＞0才会更新，保证 第二次买入不会与第一次卖出为同一天。而sell1为历史记录保证第二次买入比第一次卖出晚。</span></span><br><span class="line">            sell2 = max(sell2,buy2 + prices[i])<span class="comment">#若第二轮买卖为同一天，则不会更新。此操作自然保证sell2为买卖至多两次的最优利润。</span></span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV"></a>188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV</h2><p>DP动态规划，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n<span class="number">-1</span>][m][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown"></a>309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown</h2><p>第一种方法：标准DP动态规划，三个维度，第一维表示天，第二维表示是否处于冷冻期，第三维表示是否持有股票</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0][0]第一维表示第i天, 第二维用0,1表示是否处于冷冻期, 第三维用0,1表示是否持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：优化版的动态规划，用两个维度处理，第一维表示天，第二维用0表示未持有，1表示持有股票中，2表示处于冷冻期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天未持有, dp[i][1]表示持有股票, dp[i][2]表示前一天刚卖出今天处于冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—递归、分治相关题目</title>
      <link href="/2019-05-07-leetcode-recursion-divide-conquer/"/>
      <url>/2019-05-07-leetcode-recursion-divide-conquer/</url>
      
        <content type="html"><![CDATA[<p>有关递归与分治的做题笔记，Python实现</p><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">LeetCodeCN 第50题链接</a></p><p>第一种方法：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x * self.myPow(x, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x * x, n / <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>第二种方法：循环</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="comment"># n&amp;1 是与运算，用来求奇偶，效果与 n%2 一样</span></span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ans *= x</span><br><span class="line">            x = x * x</span><br><span class="line">            <span class="comment"># n&gt;&gt;=1 是位运算，右移一位，效果与 n//=2 一样</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="169-求众数-Majority-Element"><a href="#169-求众数-Majority-Element" class="headerlink" title="169. 求众数 Majority Element"></a>169. 求众数 Majority Element</h2><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">LeetCodeCN 第169题链接</a></p><p>第一种方法：两重循环暴力求解</p><p>第二种方法：哈希表记录每个元素出现次数，发现出现超过<code>n/2</code>的就是众数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        leng = len(nums)</span><br><span class="line">        <span class="keyword">if</span> leng == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dic[i] &gt;= leng / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>第三种方法：排序后直接返回中间值，因为题目限定条件必然存在众数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>第四种方法：用<code>list.count()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 此处如果遍历整个nums会超时</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[len(nums)//<span class="number">2</span>:]:</span><br><span class="line">        <span class="keyword">if</span> nums.count(i) &gt; len(nums)//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>第五种方法：分治</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    a = self.majorityElement(nums[:len(nums)//<span class="number">2</span>])</span><br><span class="line">    b = self.majorityElement(nums[len(nums)//<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> [b, a][nums.count(a) &gt; len(nums)//<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这个 return 的写法等同于下面的 if else</span></span><br><span class="line">    <span class="comment"># 因为若后一个[]里为True即1所以取[b,a][1]=a, False即0取[b,a][0]=b</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="comment"># if nums.count(a) &gt; len(nums)//2:</span></span><br><span class="line">    <span class="comment">#     return a</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     return b</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—二叉树相关题目</title>
      <link href="/2019-05-04-leetcode-tree/"/>
      <url>/2019-05-04-leetcode-tree/</url>
      
        <content type="html"><![CDATA[<p>有关二叉树的做题笔记，Python实现</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#98-验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="98. 验证二叉搜索树 Validate Binary Search Tree"></a>98. 验证二叉搜索树 Validate Binary Search Tree</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCodeCN 第98题链接</a></p><p>第一种方法：中序遍历二叉树存入数组，与直接升序排序去重后的原二叉树对比</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        inorder = self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> inorder == list(sorted(set(inorder)))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorder(root.left) + [root.val] + self.inorder(root.right)</span><br></pre></td></tr></table></figure><p>第二种方法：中序遍历只用比较前一节点的值是否小于当前节点的值即可，不用储存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.helper(root.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.prev <span class="keyword">and</span> self.prev.val &gt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.prev = root</span><br><span class="line">        <span class="keyword">return</span> self.helper(root.right)</span><br></pre></td></tr></table></figure><p>第三种方法：递归验证每个节点左孩子的值是否小于父亲节点的值以及右孩子的值是否大于父亲节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        mini, maxi = float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>) </span><br><span class="line">        <span class="keyword">return</span> self.isValid(root, mini, maxi)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, root: TreeNode, mini: int, maxi: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> mini &gt;= root.val <span class="keyword">or</span> maxi &lt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isValid(root.left, mini, root.val) <span class="keyword">and</span> self.isValid(root.right, root.val, maxi)</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree"></a>236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第236题链接</a></p><p>首先如果root为空，返回root，然后如果root就是p或者q，那root就是最近公共祖先。然后分别对左子树和右子树做递归并保存结果，如果两边都能找到，证明本节点就是最近公共祖先，如果一边找得到，一边找不到，则往能找到的那边继续找下去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">or</span> right:</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">elif</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree"></a>235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LeetCodeCN 第235题链接</a></p><p>第一种方法：还用上面的方法</p><p>第二种方法：利用二叉搜索树的左子树都小于父亲节点，右子树都大于父亲节点的特性，可以把第一种方法简化一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>第三种方法：跟方法二的思路一样，把递归改成循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—哈希表相关题目</title>
      <link href="/2019-05-01-leetcode-hashtable/"/>
      <url>/2019-05-01-leetcode-hashtable/</url>
      
        <content type="html"><![CDATA[<p>有关哈希表的做题笔记，Python实现</p><h2 id="242-有效的字母异位词-Valid-Anagram"><a href="#242-有效的字母异位词-Valid-Anagram" class="headerlink" title="242. 有效的字母异位词 Valid Anagram"></a>242. 有效的字母异位词 Valid Anagram</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCodeCN 第242题链接</a></p><p>第一种方法：对两个字符串排序后对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><p>第二种方法：用哈希表对字符串内每个字符计数，最后比对哈希表，这里用dict实现</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        map1, map2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            map1[i] = map1.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> t:</span><br><span class="line">            map2[j] = map2.get(j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> map1 == map2</span><br></pre></td></tr></table></figure><h2 id="1-两数之和-Two-Sum"><a href="#1-两数之和-Two-Sum" class="headerlink" title="1. 两数之和 Two Sum"></a>1. 两数之和 Two Sum</h2><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCodeCN 第1题链接</a></p><p>第一种方法：用哈希表，时间复杂度是<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:            </span><br><span class="line">                dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure><p>第二种方法：暴力两重遍历，这样时间复杂度是<code>O(n^2)</code>，在LeetCode里提交会超时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure></p><h2 id="15-三数之和-3Sum"><a href="#15-三数之和-3Sum" class="headerlink" title="15. 三数之和 3Sum"></a>15. 三数之和 3Sum</h2><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCodeCN 第15题链接</a></p><p>第一种方法：三重遍历，时间复杂度为<code>O(n^3)</code></p><p>第二种方法：两重遍历得到前两个数，然后查询第三个数<code>-(a+b)</code>是否存在。用哈希表<code>set()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = set()</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nums[:<span class="number">-2</span>]) :</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> v == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[-(v+x)] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.add((v, -(v+x), x))</span><br><span class="line">        <span class="keyword">return</span> map(list, res)</span><br></pre></td></tr></table></figure><p>第三种方法：先升序排序，一遍遍历，然后在后面的新数组里用双指针检查三个数之和是否为0，大于0则右指针向左走，小于0则左指针向右走。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums[:<span class="number">-2</span>]):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> x == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append((nums[i], nums[l], nums[r]))</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—栈、堆、队列相关题目</title>
      <link href="/2019-04-29-leetcode-stack-heap-queue/"/>
      <url>/2019-04-29-leetcode-stack-heap-queue/</url>
      
        <content type="html"><![CDATA[<p>有关栈、堆、队列的做题笔记，Python实现</p><h2 id="20-有效的括号-Valid-Parentheses"><a href="#20-有效的括号-Valid-Parentheses" class="headerlink" title="20. 有效的括号 Valid Parentheses"></a>20. 有效的括号 Valid Parentheses</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCodeCN 第20题链接</a></p><p>使用 Stack 栈 来操作，用了一个技巧是先做一个字典，<code>key</code>为右括号，<code>value</code>为左括号。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="string">')'</span>:<span class="string">'('</span>, <span class="string">'&#125;'</span>:<span class="string">'&#123;'</span>, <span class="string">']'</span>:<span class="string">'['</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> mapping[c] != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h2 id="703-数据流中的第K大元素-Kth-Largest-Element-in-a-Stream"><a href="#703-数据流中的第K大元素-Kth-Largest-Element-in-a-Stream" class="headerlink" title="703. 数据流中的第K大元素 Kth Largest Element in a Stream"></a>703. 数据流中的第K大元素 Kth Largest Element in a Stream</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">LeetCodeCN 第703题链接</a></p><p>方法一：直接降序排序，然后取第k个元素返回，add时每次都再排序一次，这样时间复杂度为<code>O(k*logk)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.直接排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">while</span> len(self.nums) &gt; k:</span><br><span class="line">            self.nums.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        self.nums.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> len(self.nums) &gt; self.k:</span><br><span class="line">            self.nums.pop()</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>方法二：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，时间复杂度降低为<code>O(k)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.小顶堆</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.pool = nums</span><br><span class="line">        heapq.heapify(self.pool)</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="keyword">while</span> len(self.pool) &gt; k:</span><br><span class="line">            heapq.heappop(self.pool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.pool) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.pool, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.pool[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(self.pool, val)</span><br><span class="line">        <span class="keyword">return</span> self.pool[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = KthLargest(k, nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.add(val)</span></span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值-Sliding-Window-Maximum"><a href="#239-滑动窗口最大值-Sliding-Window-Maximum" class="headerlink" title="239. 滑动窗口最大值 Sliding Window Maximum"></a>239. 滑动窗口最大值 Sliding Window Maximum</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCodeCN 第239题链接</a></p><p>第一种方法：用优先队列：大顶堆</p><p>第二种方法：因为窗口大小固定，只需要一个双端队列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        window, res = [], []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> window[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                window.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> nums[window[<span class="number">-1</span>]] &lt;= x:</span><br><span class="line">                window.pop()</span><br><span class="line">            window.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">                res.append(nums[window[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记--链表相关题目</title>
      <link href="/2019-04-28-leetcode-linklist/"/>
      <url>/2019-04-28-leetcode-linklist/</url>
      
        <content type="html"><![CDATA[<p>有关链表的做题笔记，Python实现</p><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表-Reverse-Linked-List"><a href="#206-反转链表-Reverse-Linked-List" class="headerlink" title="206. 反转链表 Reverse Linked List"></a>206. 反转链表 Reverse Linked List</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCodeCN 第206题链接</a></p><p>遍历链表，迭代前节点prev，缓存当前节点current的下一节点，然后把当前节点的next指针指向前节点prev</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        current = head</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            tmp = current.next</span><br><span class="line">            current.next = prev</span><br><span class="line">            prev = current</span><br><span class="line">            current = tmp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>用Python三元交换能同时赋值不需要缓存的特性可以一行完成交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        current = head</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            current.next, prev, current = prev, current, current.next</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点-Swap-Nodes-in-Pairs"><a href="#24-两两交换链表中的节点-Swap-Nodes-in-Pairs" class="headerlink" title="24. 两两交换链表中的节点 Swap Nodes in Pairs"></a>24. 两两交换链表中的节点 Swap Nodes in Pairs</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">LeetCodeCN 第24题链接</a></p><p>记录当前节点的前一个节点，当当前节点和下一节点都存在时，三元交换三个节点的next指针<br>返回交换完后的首节点（这里不太明白为什么self的取值是ListNode(None)）</p><blockquote><p>看到好多小伙伴在问，我来尝试解释一下“链表交换相邻元素”中 self 是怎么回事。<br>1.首先看到最后 return self.next ，可以看到作者是想把 self 当做链表的头指针使用的（注意：头指针 pHead 与传入的参数 head 是不同的，head 是第一个结点，而 pHead.next == next ）。用头指针有什么好处呢？因为我们让头指针的 next 域（pHead.next）永远指向第一个结点，就是避免最后返回的时候找不到第一个结点了。<br>2.那么作者为什么可以 pre, pre.next = self, head 这样写呢？因为 self 是这个类的一个对象，所以在类定义的时候可以在任何地方，给 self 增加新的属性。相信大家都知道在 <strong>init</strong>(self, attr) 里面可以定义通过 self.myattr = attr 来定义一个 myattr 属性。其实这个语句写在任意一个类的方法里都可以，所以在原文 swapPairs() 里面当然也可以定义新的属性。所以这行代码应该理解为，pre 指向 self（虽然 self 不是一个 ListNode 类型的对象，但它只要有一个 next 就可以了），同时为 pre（同时也是为 self，它们是一样的现在）增加一个 next 属性，这个 next 属性指向第一个结点 head。<br>3.明白上面之后，这里就好办了。在第一次 while 循环的时候，pre.next 被赋值为 b（也就是原来第二个结点，转换为变成了第一个，也就成为了新链表的第一个结点。如果原来是[1,2,3,4]，那么现在就是[2,1,3,4]，这个 self.next 就是指向 2 这个结点）。所以最后只要返回 self.next 就得到了答案。<br>其实换个写法大家就好理解很多了：<br>pHead = ListNode(None)<br>pre, pre.next = pHead, head<br>也就是说不用 self 也可以，只是原作者秀了一把小技巧而已。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre, pre.next = self, head</span><br><span class="line">        <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">            l = pre.next</span><br><span class="line">            r = l.next</span><br><span class="line">            pre.next, l.next, r.next = r, r.next, l</span><br><span class="line">            pre = l</span><br><span class="line">        <span class="keyword">return</span> self.next</span><br></pre></td></tr></table></figure><h2 id="141-环形链表-Linked-List-Cycle"><a href="#141-环形链表-Linked-List-Cycle" class="headerlink" title="141. 环形链表 Linked List Cycle"></a>141. 环形链表 Linked List Cycle</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCodeCN 第141题链接</a></p><p>三种方法<br>1.硬做，可以设置超时或者固定循环次数，不靠谱<br>2.做记号，使用set来储存遍历过的节点，需要额外内存空间<br>3.快慢指针，慢指针每次前移一个节点，快指针每次前移两个节点，如果链表存在循环那快慢指针肯定会相遇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 1.硬做</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle1</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">            curr = curr.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2.set记录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle2</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rec = set()</span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr <span class="keyword">in</span> rec:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            rec.add(curr)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle3</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II-Linked-List-Cycle-II"><a href="#142-环形链表-II-Linked-List-Cycle-II" class="headerlink" title="142. 环形链表 II Linked List Cycle II"></a>142. 环形链表 II Linked List Cycle II</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCodeCN 第142题链接</a></p><p>第一种方法还是上面的用哈希表set来记录，占用空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 1.set记录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rec = []</span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr <span class="keyword">in</span> rec:</span><br><span class="line">                <span class="keyword">return</span> rec[rec.index(curr)]</span><br><span class="line">            rec.append(curr)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>第二种方法用快慢指针，先如上题一样检测是否有环，有的话设置一个新的检测节点从头(head)开始迭代，同时slow节点也继续迭代，直到二者相遇的点就是环的入口节点。</p><blockquote><p>原理：<br>首先，头结点到入环结点的距离为a，入环结点到相遇结点的距离为b，相遇结点到入环结点的距离为c。然后，当f以s的两倍速度前进并和s相遇时，f走过的距离是s的两倍，即有等式：a+b+c+b = 2(a+b) ，可以得出 a = c ，所以说，让fast和slow分别从相遇结点和头结点同时同步长出发，他们的相遇结点就是入环结点。<br>当快、慢指针同时从入环点出发，那么一定会在入环点相遇。如果快、慢指针同时从入环点前一节点出发，那么快慢、指针则会在入环点的前一节点相遇，以此类推。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 2.快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                detection = head</span><br><span class="line">                <span class="keyword">while</span> slow != detection:</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    detection = detection.next</span><br><span class="line">                <span class="keyword">return</span> detection</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="25-k个一组翻转链表-Reverse-Nodes-in-k-Group"><a href="#25-k个一组翻转链表-Reverse-Nodes-in-k-Group" class="headerlink" title="25. k个一组翻转链表 Reverse Nodes in k-Group"></a>25. k个一组翻转链表 Reverse Nodes in k-Group</h2><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCodeCN 第25题链接</a></p><p>利用数组来实现k个一组的翻转，然后重新连接成链表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        arr, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(arr) - k:</span><br><span class="line">            arr[i:i+k] = arr[i:i+k][::<span class="number">-1</span>]</span><br><span class="line">            i += k</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>):</span><br><span class="line">            arr[j].next = arr[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> arr:</span><br><span class="line">            arr[<span class="number">-1</span>].next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 NSUserDefaults setBool 的值取出后if判断不了的问题</title>
      <link href="/2019-04-23-nsuserdefaults-setbool-forkey/"/>
      <url>/2019-04-23-nsuserdefaults-setbool-forkey/</url>
      
        <content type="html"><![CDATA[<p>使用  <code>[[NSUserDefaults standardUserDefaults] setBool:(BOOL)value forKey:(NSString *)defaultName]</code> 设置的值，如果用普通的<code>objectForKey:</code>取出的值是<code>__NSCFBoolean</code>类型，<code>if</code>语句无法判断，即使后加<code>== YES</code>也没用，还会出问题。</p><p>要用 <code>[[NSUserDefaults standardUserDefaults] boolForKey:(NSString *)defaultName]</code> 来取值，</p><p>同理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInteger:(<span class="built_in">NSInteger</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setFloat:(<span class="keyword">float</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setDouble:(<span class="keyword">double</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setBool:(<span class="built_in">BOOL</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br></pre></td></tr></table></figure></p><p>如上所示等入值方法，都用对应配套的取值方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)integerForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">float</span>)floatForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">double</span>)doubleForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="built_in">BOOL</span>)boolForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)URLForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS集成支付宝H5支付实现跳转与回调的解决方案</title>
      <link href="/2019-03-22-ios-alipay-h5-solution/"/>
      <url>/2019-03-22-ios-alipay-h5-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。</p><p>这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇：</p><blockquote><p> <a href="https://paaatrick.com/2019-03-22-ios-wxpay-h5-solution/">iOS集成H5微信支付实现跳转与回调的解决方案</a></p></blockquote><p>实现的效果是：App→支付宝→支付(成功失败或取消)→App</p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>本项目使用WKWebView，前置动作是后端小伙伴已经处理好支付宝H5支付下单链接，客户端接收到下单链接后的操作。</p><p>下单链接即为<a href="https://docs.open.alipay.com/203/107090/" target="_blank" rel="noopener">支付宝H5支付文档-参数说明-公共参数</a>中构造的<code>https://openapi.alipay.com/gateway.do</code>开头的的链接，构造链接的操作交由后端处理。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322204641.png" alt></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-添加-URL-Scheme-并把支付宝加入白名单"><a href="#1-添加-URL-Scheme-并把支付宝加入白名单" class="headerlink" title="1. 添加 URL Scheme 并把支付宝加入白名单"></a>1. 添加 URL Scheme 并把支付宝加入白名单</h2><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175421.png" alt></p><p>添加 URL Scheme。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡最下面的 <code>URL Types</code>内设置。 该 URL Scheme 不像微信支付因为要校验必须设置商户后台填的一级域名，支付宝的这个可以任意设置。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175420.png" alt></p><p>把支付宝的 URL Scheme <code>alipay</code> 和 <code>alipays</code> 填入项目的白名单。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡内的 <code>Custom iOS Target Properties</code> 的 <code>LSApplicationQueriesSchemes</code> 里添加上述两个字符串，若没有 <code>LSApplicationQueriesSchemes</code> 就手动输入添加，类型为数组 Array。</p><h2 id="2-WKWebView加载链接"><a href="#2-WKWebView加载链接" class="headerlink" title="2. WKWebView加载链接"></a>2. WKWebView加载链接</h2><p>添加协议 <code>WKNavigationDelegate</code>和<code>WKUIDelegate</code>。</p><p>创建一个WKWebView，并加载统一下单链接。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buildWKWebView &#123;</span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:webView];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    webView.UIDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *payURL = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.payString];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:payURL];</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处self.payString就是后台传来的支付宝5支付统一下单链接，格式为：</p><p><code>https://openapi.alipay.com/gateway.do?app_id=2015081808011180&amp;biz_content={&quot;body&quot;%3A&quot;支付宝充值&quot;%2C&quot;subject&quot;%3A&quot;10000宝石&quot;%2C&quot;out_trade_no&quot;%3A&quot;30677&quot;%2C&quot;total_amount&quot;%3A&quot;1.00&quot;%2C&quot;seller_id&quot;%3A&quot;2088721584425035&quot;%2C&quot;product_code&quot;%3A&quot;QUICK_WAP_PAY&quot;%2C&quot;goods_type&quot;%3A&quot;1&quot;%2C&quot;passback_params&quot;%3A&quot;20190322083556lkkzmwT2wi0bAaFL1W&quot;%2C&quot;store_id&quot;%3A&quot;company&quot;%2C&quot;timeout_express&quot;%3A&quot;3m&quot;}&amp;charset=UTF-8&amp;format=JSON&amp;method=alipay.trade.wap.pay&amp;notify_url=https%3A%2F%2Fsttv3-api.company.com%2FaliNotify&amp;return_url=https%3A%2F%2Fwww.company.com&amp;sign_type=RSA2&amp;timestamp=2019-03-22+20%3A35%3A56&amp;version=1.0&amp;sign=rmnKUOsZBYi%2BWzDELY%2B5ixnSFn0b0S38K0NR45SRZBAvmzr0qaXm7mnKaXm7OrvmnKUOsZRYiaJ2LNAaFL1K0hvJ3L3hZqH5HifNCIJ0hfTr1OkA5Lgyn1SCx74SrSWVfXdMXqiLurpN0Mj%2B2zs7vDee%2B8vxwzhRG3a5EaZbOHDQFN1%2OrvvVcdv%2F%2FBJCwISBhoXhBelvfZRYiaJ2LNAaFL1KdrJvjlo2lR%2BEzvda0ppMKFzjMLxRZBAvmzr0qNwxyTMfAuxjAT2%2BXAaF3hZqH5Hlo2lRiaJ2LNE</code></p><p>不像微信支付还要加个请求头，支付宝的简单的多，直接访问即可。</p><h2 id="3-实现代理方法拦截链接并跳转支付宝"><a href="#3-实现代理方法拦截链接并跳转支付宝" class="headerlink" title="3. 实现代理方法拦截链接并跳转支付宝"></a>3. 实现代理方法拦截链接并跳转支付宝</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([navigationAction.request.URL.scheme isEqualToString:<span class="string">@"alipay"</span>]) &#123;</span><br><span class="line">        <span class="comment">//  1.以？号来切割字符串</span></span><br><span class="line">        <span class="built_in">NSArray</span> *urlBaseArr = [navigationAction.request.URL.absoluteString componentsSeparatedByString:<span class="string">@"?"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *urlBaseStr = urlBaseArr.firstObject;</span><br><span class="line">        <span class="built_in">NSString</span> *urlNeedDecode = urlBaseArr.lastObject;</span><br><span class="line">        <span class="comment">//  2.将截取以后的Str，做一下URLDecode，方便我们处理数据</span></span><br><span class="line">        <span class="built_in">NSMutableString</span> *afterDecodeStr = [<span class="built_in">NSMutableString</span> stringWithString:[SmallTools decoderUrlEncodeStr:urlNeedDecode]];</span><br><span class="line">        <span class="comment">//  3.替换里面的默认Scheme为自己的Scheme</span></span><br><span class="line">        <span class="built_in">NSString</span> *afterHandleStr = [afterDecodeStr stringByReplacingOccurrencesOfString:<span class="string">@"alipays"</span> withString:<span class="string">@"alipayreturn.company.com"</span>];</span><br><span class="line">        <span class="comment">//  4.然后把处理后的，和最开始切割的做下拼接，就得到了最终的字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *finalStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>,urlBaseStr, [SmallTools urlEncodeStr:afterHandleStr]];</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//  判断一下，是否安装了支付宝APP（也就是看看能不能打开这个URL）</span></span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:finalStr]]) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:finalStr]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//未安装支付宝, 自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便附带一下 URL 的 Encode 和 Decode 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlEncode编码</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)urlEncodeStr:(<span class="built_in">NSString</span> *)input &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *charactersToEscape = <span class="string">@"?!@#$^&amp;%*+,:;='\"`&lt;&gt;()[]&#123;&#125;/\\| "</span>;</span><br><span class="line">    <span class="built_in">NSCharacterSet</span> *allowedCharacters = [[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:charactersToEscape] invertedSet];</span><br><span class="line">    <span class="built_in">NSString</span> *upSign = [input stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];</span><br><span class="line">    <span class="keyword">return</span> upSign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//urlEncode解码</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decoderUrlEncodeStr: (<span class="built_in">NSString</span> *) input &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *outputStr = [<span class="built_in">NSMutableString</span> stringWithString:input];</span><br><span class="line">    [outputStr replaceOccurrencesOfString:<span class="string">@"+"</span> withString:<span class="string">@""</span> options:<span class="built_in">NSLiteralSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>,[outputStr length])];</span><br><span class="line">    <span class="keyword">return</span> [outputStr stringByRemovingPercentEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-AppDelegate-中接收跳转动作"><a href="#4-AppDelegate-中接收跳转动作" class="headerlink" title="4. AppDelegate 中接收跳转动作"></a>4. AppDelegate 中接收跳转动作</h2><p>当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。</p><p>以下是AppDelegate接收返回动作的示例。</p><p>其中支付宝回调的 host 是固定的 safepay，而微信支付的 host 随意定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)options&#123;</span><br><span class="line">    <span class="comment">//safepay是支付宝H5支付的回调host, </span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"wxpaycallback"</span>] || [url.host isEqualToString:<span class="string">@"safepay"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarVC = (<span class="built_in">UITabBarController</span> *)topRootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex];</span><br><span class="line">        [navVC popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *orderId = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayOrderId"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *payFee = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayFee"</span>];</span><br><span class="line">            <span class="comment">//以及更多参数</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDict = @&#123;<span class="string">@"order_id"</span>:orderId, <span class="string">@"payFee"</span>:payFee&#125;;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"htmlPaymentNotification"</span> object:<span class="keyword">self</span> userInfo:resultDict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS集成H5微信支付实现跳转与回调的解决方案</title>
      <link href="/2019-03-22-ios-wxpay-h5-solution/"/>
      <url>/2019-03-22-ios-wxpay-h5-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。</p><p>这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇：</p><blockquote><p> <a href="https://paaatrick.com/2019-03-22-ios-alipay-h5-solution/">iOS集成支付宝H5支付实现跳转与回调的解决方案</a></p></blockquote><p>实现的效果是：App→微信→支付(成功失败或取消)→App</p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>本项目使用WKWebView，前置动作是后端小伙伴已经处理好微信H5支付下单链接，客户端接收到下单链接后的操作。</p><p>下单链接即为<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_20&amp;index=1" target="_blank" rel="noopener">微信支付文档-统一下单API</a>中返回的 <code>mweb_url</code>，格式为 <code>https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241</code>。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322180048.png" alt></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-添加-URL-Scheme-并把微信加入白名单"><a href="#1-添加-URL-Scheme-并把微信加入白名单" class="headerlink" title="1. 添加 URL Scheme 并把微信加入白名单"></a>1. 添加 URL Scheme 并把微信加入白名单</h2><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175422.png" alt></p><p>添加 URL Scheme。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡最下面的 <code>URL Types</code>内设置。 注意此URL的一级域名需要与微信商户后台(微信商户平台-产品中心-开发配置-H5支付)设置的的一级域名一致，比如微信商户里设置的是<code>company.com</code>，那 URL Schemes 可以设为 <code>a1.company.com</code>，此特性使得一套H5支付可以方便得集成到多个App。只有一个App需要H5支付的话也可以直接填与微信后台的一致的 <code>company.com</code> 。</p><blockquote><p>2019年4月10日更新<br>如果像上图那样填的是 <code>www.company.com</code>，那 URL Scheme 只能设为其三级域名如 <code>a2.www.company.com</code> 或同样的 <code>www.company.com</code></p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175420.png" alt></p><p>把微信的 URL Scheme <code>weixin</code> 和 <code>wechat</code> 填入项目的白名单。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡内的 <code>Custom iOS Target Properties</code> 的 <code>LSApplicationQueriesSchemes</code> 里添加上述两个字符串，若没有 <code>LSApplicationQueriesSchemes</code> 就手动输入添加，类型为数组 Array。</p><h2 id="2-WKWebView加载链接"><a href="#2-WKWebView加载链接" class="headerlink" title="2. WKWebView加载链接"></a>2. WKWebView加载链接</h2><p>添加协议 <code>WKNavigationDelegate</code>和<code>WKUIDelegate</code>。</p><p>创建一个WKWebView，并加载统一下单链接。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buildWKWebView &#123;</span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:webView];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    webView.UIDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *payURL = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.payString];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:payURL];</span><br><span class="line">    [request setValue:<span class="string">@"a1.company.com://wxpaycallback/"</span> forHTTPHeaderField:<span class="string">@"Referer"</span>];</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处self.payString就是后台传来的微信H5支付统一下单链接，格式为 <code>https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458041</code>。</p><p>我们需要做的处理是根据文档给这个请求添加请求头 <code>Referer</code>，关键在于这个 <code>a1.company.com://wxpaycallback/</code> 既满足了微信检测到有商户后台设置好的一级域名，同时把这个链接做成了 URL Scheme 使得可以在跳转微信客户端后（不管支付成功还是失败）能顺利跳转回自己的App。其中的 host <code>wxpaycallback/</code> 可以任意设置，方便在 <code>AppDelegate</code> 里处理跳转回来后部署业务逻辑。当然如果你不需要在 <code>AppDelegate</code> 里接收动作而是直接跳回支付界面自行后续处理的话就只用设为前一步在 URL Scheme <code>a1.company.com://</code> 即可。</p><blockquote><p>2019.4.10 更新 </p><p>经过测试，对于App内的H5支付而言，实际上是下面步骤里<br><code>@&quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb&quot;</code><br>后接的参数 <code>redirect_url</code> 对支付后跳回App起作用，<code>Referer</code>只起到给微信校验的作用。</p><p>所以 <code>Referer</code> 只需要设置成微信H5支付登记的域名的子域名即可，如<br><code>[request setValue:@&quot;a1.company.com&quot; forHTTPHeaderField:@&quot;Referer&quot;];</code></p></blockquote><h2 id="3-实现代理方法拦截链接并跳转微信"><a href="#3-实现代理方法拦截链接并跳转微信" class="headerlink" title="3. 实现代理方法拦截链接并跳转微信"></a>3. 实现代理方法拦截链接并跳转微信</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = navigationAction.request;</span><br><span class="line">    <span class="built_in">NSString</span> *absoluteString = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拦截WKWebView加载的微信支付统一下单链接, 将redirect_url参数修改为唤起自己App的URLScheme</span></span><br><span class="line">    <span class="keyword">if</span> ([absoluteString hasPrefix:<span class="string">@"https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb"</span>] &amp;&amp; ![absoluteString hasSuffix:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]]) &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *redirectUrl = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> ([absoluteString containsString:<span class="string">@"redirect_url="</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSRange</span> redirectRange = [absoluteString rangeOfString:<span class="string">@"redirect_url"</span>];</span><br><span class="line">            redirectUrl = [[absoluteString substringToIndex:redirectRange.location] stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redirectUrl = [absoluteString stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *newRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:redirectUrl] cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">30</span>];</span><br><span class="line">        newRequest.allHTTPHeaderFields = request.allHTTPHeaderFields;</span><br><span class="line">        newRequest.URL = [<span class="built_in">NSURL</span> URLWithString:redirectUrl];</span><br><span class="line">        [webView loadRequest:newRequest];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拦截重定向的跳转微信的 URL Scheme, 打开微信</span></span><br><span class="line">    <span class="keyword">if</span> ([absoluteString hasPrefix:<span class="string">@"weixin://"</span>]) &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:navigationAction.request.URL]) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] openURL:navigationAction.request.URL];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//未安装微信, 自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-AppDelegate-中接收跳转动作"><a href="#4-AppDelegate-中接收跳转动作" class="headerlink" title="4. AppDelegate 中接收跳转动作"></a>4. AppDelegate 中接收跳转动作</h2><p>当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。</p><p>以下是AppDelegate接收返回动作的示例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)options&#123;</span><br><span class="line">    <span class="comment">//safepay是支付宝H5支付的回调host</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"wxpaycallback"</span>] || [url.host isEqualToString:<span class="string">@"safepay"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarVC = (<span class="built_in">UITabBarController</span> *)topRootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex];</span><br><span class="line">        [navVC popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *orderId = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayOrderId"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *payFee = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayFee"</span>];</span><br><span class="line">            <span class="comment">//以及更多参数</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDict = @&#123;<span class="string">@"order_id"</span>:orderId, <span class="string">@"payFee"</span>:payFee&#125;;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"htmlPaymentNotification"</span> object:<span class="keyword">self</span> userInfo:resultDict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-关于微信H5支付域名设置"><a href="#5-关于微信H5支付域名设置" class="headerlink" title="5. 关于微信H5支付域名设置"></a>5. 关于微信H5支付域名设置</h2><blockquote><p>2019年4月10日更新</p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190410183635.png" alt></p><p>这里额外提一下，截止到2019年4月，微信支付设置页面明确说了</p><blockquote><p>添加域名后，其所属的子域名将都有权限</p></blockquote><p>也就是说只需要填一个一级域名比如 <code>company.com</code> ，就可以有无限多个二级域名可供不同App使用，绕过微信H5支付只能添加5个域名的限制。如果填的是二级域名比如 <code>www.company.com</code>，那么只能往下使用三级域名比如 <code>a1.www.company.com</code></p><p>以微信H5支付域名填了 <code>company.com</code> 为例，那可以这样操作</p><table><thead><tr><th style="text-align:center">App</th><th style="text-align:center">Alpha</th><th style="text-align:center">Beta-A1</th><th style="text-align:center">Beta-A2</th><th>Gamma</th></tr></thead><tbody><tr><td style="text-align:center">添加的Referer</td><td style="text-align:center">alpha.company.com</td><td style="text-align:center">a1.beta.company.com</td><td style="text-align:center">a2.beta.company.com</td><td>gamma.company.com</td></tr><tr><td style="text-align:center">要替换的redirect_url</td><td style="text-align:center">alpha.company.com://optional</td><td style="text-align:center">a1.beta.company.com://</td><td style="text-align:center">a2.beta.company.com://optional</td><td>gamma.company.com://</td></tr><tr><td style="text-align:center">URL Scheme</td><td style="text-align:center">alpha.company.com</td><td style="text-align:center">a1.beta.company.com</td><td style="text-align:center">a2.beta.company.com</td><td>gamma.company.com</td></tr></tbody></table><p><a href="https://www.cnblogs.com/Life-Record/p/8472319.html" target="_blank" rel="noopener"><strong>参考博客链接</strong></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个 NSArray 是否为空</title>
      <link href="/2019-03-12-if-nsarray-null/"/>
      <url>/2019-03-12-if-nsarray-null/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([array isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp; array.count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"这是一个非空数组"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPhone屏幕各种尺寸分辨率（更新至XS）</title>
      <link href="/2019-03-05-iphone-pixel-point-size-scale/"/>
      <url>/2019-03-05-iphone-pixel-point-size-scale/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>Device</th><th>Logic Point</th><th>Logic Pixel</th><th>Size</th><th>Scale</th></tr></thead><tbody><tr><td>iPhone 2G</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 3</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 3GS</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 4</td><td>480 × 320</td><td>960 × 640</td><td>3.5</td><td>2x</td></tr><tr><td>iPhone 4S</td><td>480 × 320</td><td>960 × 640</td><td>3.5</td><td>2x</td></tr><tr><td>iPhone 5</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 5S</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 5C</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 6</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 6 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone 6S</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 6S Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone SE</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 7</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 7 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone 8</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 8 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone X</td><td>812 × 375</td><td>2436 × 1125</td><td>5.8</td><td>3x</td></tr><tr><td>iPhone XS</td><td>812 × 375</td><td>2436 × 1125</td><td>5.8</td><td>3x</td></tr><tr><td>iPhone XR</td><td>896 × 414</td><td>1792 × 828</td><td>6.1</td><td>2x</td></tr><tr><td>iPhone XS Max</td><td>896 × 414</td><td>2688 × 1242</td><td>6.5</td><td>3x</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS处理多线程异步Block中的UI操作</title>
      <link href="/2019-02-23-ios-block-and-mainqueue/"/>
      <url>/2019-02-23-ios-block-and-mainqueue/</url>
      
        <content type="html"><![CDATA[<p>多线程方法的<code>completionHandler</code>block可能运行在非主线程上。两种处理方法：</p><ol><li>在block里手动加上<code>dispatch_async(dispatch_get_main_queue(), ^{});</code></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];<span class="comment">//no delegateQueue</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url] cachePolicy:<span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> timeoutInterval:<span class="number">30.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<span class="comment">/* do UI things */</span>&#125;);</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doUIthings) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><ol start="2"><li>带有<code>delegateQueue</code>等参数的方法，可传入主线程队列，然后block<code>completionHandler</code>便运行在主线程了。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];<span class="comment">//get the mainQueue</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url] cachePolicy:<span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> timeoutInterval:<span class="number">30.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">/* do UI things */</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 判断NSString值是否为空或null并转换为空字符串</title>
      <link href="/2019-02-12-transfer-null-to-nsstring/"/>
      <url>/2019-02-12-transfer-null-to-nsstring/</url>
      
        <content type="html"><![CDATA[<p>遇到了一个后台json误将null作为字符串值导致iOS客户端崩溃闪退的问题，解决方法如下：套一层判断，如果是各种情况的null则转换为@””。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *) nullToString:(<span class="keyword">id</span>)string &#123;</span><br><span class="line">    <span class="keyword">if</span> ([string isEqual:<span class="string">@"NULL"</span>] || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [string isEqual:[<span class="built_in">NSNull</span> null]] || [string isEqual:<span class="literal">NULL</span>] || [[string <span class="keyword">class</span>] isSubclassOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || string == <span class="literal">nil</span> || string == <span class="literal">NULL</span> || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [[string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]] length]==<span class="number">0</span> || [string isEqualToString:<span class="string">@"&lt;null&gt;"</span>] || [string isEqualToString:<span class="string">@"(null)"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">NSString</span> *)string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS MJExtension使用方法指南(Objective-C)</title>
      <link href="/2019-02-03-mj-extension-guide/"/>
      <url>/2019-02-03-mj-extension-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="MJExtension能做什么？"><a href="#MJExtension能做什么？" class="headerlink" title="MJExtension能做什么？"></a>MJExtension能做什么？</h2><h5 id="1-MJExtension是一套字典和模型之间互相转换的超轻量级框架"><a href="#1-MJExtension是一套字典和模型之间互相转换的超轻量级框架" class="headerlink" title="1. MJExtension是一套字典和模型之间互相转换的超轻量级框架"></a>1. MJExtension是一套字典和模型之间互相转换的超轻量级框架</h5><h5 id="2-MJExtension能完成的功能"><a href="#2-MJExtension能完成的功能" class="headerlink" title="2. MJExtension能完成的功能"></a>2. MJExtension能完成的功能</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字典（JSON） --&gt; 模型（Model）</span><br><span class="line">模型（Model） --&gt; 字典（JSON）</span><br><span class="line">字典数组（JSON Array） --&gt; 模型数组（Model Array）</span><br><span class="line">模型数组（Model Array） --&gt; 字典数组（JSON Array）</span><br></pre></td></tr></table></figure><p><code>详尽用法主要参考 main.m中的各个函数 以及 NSObject+MJKeyValue.h</code></p><h2 id="MJExtension和JSONModel、Mantle等框架的区别"><a href="#MJExtension和JSONModel、Mantle等框架的区别" class="headerlink" title="MJExtension和JSONModel、Mantle等框架的区别"></a>MJExtension和JSONModel、Mantle等框架的区别</h2><h5 id="1-转换速率："><a href="#1-转换速率：" class="headerlink" title="1. 转换速率："></a>1. 转换速率：</h5><p>最近一次测试表明：<code>MJExtension &gt; JSONModel &gt; Mantle</code> 各位开发者也可以自行测试</p><h5 id="2-具体用法："><a href="#2-具体用法：" class="headerlink" title="2. 具体用法："></a>2. 具体用法：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSONModel：</span><br><span class="line"></span><br><span class="line">要求所有模型类必须继承自JSONModel基类</span><br><span class="line"></span><br><span class="line">Mantle：</span><br><span class="line"></span><br><span class="line">要求所有模型类必须继承自MTModel基类</span><br><span class="line"></span><br><span class="line">MJExtension：</span><br><span class="line"></span><br><span class="line">不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性</span><br></pre></td></tr></table></figure><h2 id="如何安装MJExtension"><a href="#如何安装MJExtension" class="headerlink" title="如何安装MJExtension"></a>如何安装MJExtension</h2><p>方法一：cocoapods导入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod 'MJExtension'</span><br></pre></td></tr></table></figure><p>方法二：手动导入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将MJExtensionExample/MJExtensionExample/MJExtension文件夹中的所有源代码拽入项目中</span><br><span class="line">导入主头文件：<span class="meta">#import <span class="meta-string">"MJExtension.h"</span></span></span><br><span class="line">MJExtension.h</span><br><span class="line">MJConst.h</span><br><span class="line">MJConst.m</span><br><span class="line">MJFoundation.h</span><br><span class="line">MJFoundation.m</span><br><span class="line">MJIvar.h</span><br><span class="line">MJIvar.m</span><br><span class="line">MJType.h</span><br><span class="line">MJType.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJCoding.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJCoding.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJIvar.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJIvar.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJKeyValue.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJKeyValue.m</span><br></pre></td></tr></table></figure><h2 id="如何使用MJExtension"><a href="#如何使用MJExtension" class="headerlink" title="如何使用MJExtension"></a>如何使用MJExtension</h2><h4 id="1-最简单的字典转模型"><a href="#1-最简单的字典转模型" class="headerlink" title="1. 最简单的字典转模型"></a>1. 最简单的字典转模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    SexMale,    </span><br><span class="line">    SexFemale&#125; Sex;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *icon;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *money;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) Sex sex;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                        <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                 </span><br><span class="line">                        <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>,               </span><br><span class="line">                        <span class="string">@"age"</span> : @<span class="number">20</span>,               </span><br><span class="line">                        <span class="string">@"height"</span> : <span class="string">@"1.55"</span>,               </span><br><span class="line">                        <span class="string">@"money"</span> : @<span class="number">100.9</span>,               </span><br><span class="line">                        <span class="string">@"sex"</span> : @(SexFemale)            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为User模型</span></span><br><span class="line">User *user = [User objectWithKeyValues:dict];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name=%@, icon=%@, age=%d, height=%@, money=%@, sex=%d"</span>, user.name, user.icon, user.age, user.height, user.money, user.sex);</span><br><span class="line"><span class="comment">// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1</span></span><br></pre></td></tr></table></figure><h5 id="核心代码1："><a href="#核心代码1：" class="headerlink" title="核心代码1："></a>核心代码1：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="2-模型中嵌套模型"><a href="#2-模型中嵌套模型" class="headerlink" title="2. 模型中嵌套模型"></a>2. 模型中嵌套模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Status</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 微博文本内容 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *text;</span><br><span class="line"><span class="comment">/** 微博作者 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) User *user;</span><br><span class="line"><span class="comment">/** 转发的微博 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Status *retweetedStatus;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;               </span><br><span class="line"><span class="string">@"text"</span> : <span class="string">@"是啊，今天天气确实不错！"</span>, </span><br><span class="line"><span class="string">@"user"</span> : @&#123;                   </span><br><span class="line">             <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                   </span><br><span class="line">             <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>                </span><br><span class="line">           &#125;,               </span><br><span class="line"><span class="string">@"retweetedStatus"</span> : @&#123;                   </span><br><span class="line">                        <span class="string">@"text"</span> : <span class="string">@"今天天气真不错！"</span>,                   </span><br><span class="line">                        <span class="string">@"user"</span> : @&#123;                       </span><br><span class="line">                                    <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,                       </span><br><span class="line">                                    <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>                    </span><br><span class="line">                                   &#125;                </span><br><span class="line">                       &#125;            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为Status模型</span></span><br><span class="line">Status *status = [Status objectWithKeyValues:dict];</span><br><span class="line"><span class="built_in">NSString</span> *text = status.text;</span><br><span class="line"><span class="built_in">NSString</span> *name = status.user.name;</span><br><span class="line"><span class="built_in">NSString</span> *icon = status.user.icon;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text=%@, name=%@, icon=%@"</span>, text, name, icon);</span><br><span class="line"><span class="comment">// text=是啊，今天天气确实不错！, name=Jack, icon=lufy.png</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *text2 = status.retweetedStatus.text;</span><br><span class="line"><span class="built_in">NSString</span> *name2 = status.retweetedStatus.user.name;</span><br><span class="line"><span class="built_in">NSString</span> *icon2 = status.retweetedStatus.user.icon;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text2=%@, name2=%@, icon2=%@"</span>, text2, name2, icon2);</span><br><span class="line"><span class="comment">// text2=今天天气真不错！, name2=Rose, icon2=nami.png</span></span><br></pre></td></tr></table></figure><h5 id="核心代码2"><a href="#核心代码2" class="headerlink" title="核心代码2"></a>核心代码2</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Status objectWithKeyValues:dict]`</span><br></pre></td></tr></table></figure><h4 id="3-模型中有个数组属性，数组里面又要装着其它模型"><a href="#3-模型中有个数组属性，数组里面又要装着其它模型" class="headerlink" title="3. 模型中有个数组属性，数组里面又要装着其它模型"></a>3. 模型中有个数组属性，数组里面又要装着其它模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Ad</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">StatusResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 存放着一堆的微博数据（里面都是Status模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *statuses;</span><br><span class="line"><span class="comment">/** 存放着一堆的广告数据（里面都是Ad模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *ads;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *totalNumber;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StatusResult</span></span></span><br><span class="line"><span class="comment">// 实现这个方法的目的：告诉MJExtension框架statuses和ads数组里面装的是什么模型</span></span><br><span class="line"><span class="comment">/*    + (NSDictionary *)objectClassInArray&#123;    </span></span><br><span class="line"><span class="comment">return @&#123;         </span></span><br><span class="line"><span class="comment">@"statuses" : [Status class],         </span></span><br><span class="line"><span class="comment">@"ads" : [Ad class]    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">+ (Class)objectClassInArray:(NSString *)propertyName&#123;    </span></span><br><span class="line"><span class="comment">if ([propertyName isEqualToString:@"statuses"]) &#123;        </span></span><br><span class="line"><span class="comment">return [Status class];    </span></span><br><span class="line"><span class="comment">&#125; else if ([propertyName isEqualToString:@"ads"]) &#123;        </span></span><br><span class="line"><span class="comment">return [Ad class];    &#125;    </span></span><br><span class="line"><span class="comment">return nil;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法对比上面的2个方法更加没有侵入性和污染，因为不需要导入Status和Ad的头文件</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray&#123;    </span><br><span class="line">    <span class="keyword">return</span> @&#123;         </span><br><span class="line">              <span class="string">@"statuses"</span> : <span class="string">@"Status"</span>,         </span><br><span class="line">              <span class="string">@"ads"</span> : <span class="string">@"Ad"</span>    </span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;                       </span><br><span class="line"><span class="string">@"statuses"</span> : @[                           </span><br><span class="line">                @&#123;                                   </span><br><span class="line">                   <span class="string">@"text"</span> : <span class="string">@"今天天气真不错！"</span>,</span><br><span class="line">                   <span class="string">@"user"</span> : @&#123;                                   </span><br><span class="line">                                <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,</span><br><span class="line">                                <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>                                                                                  </span><br><span class="line">                              &#125;                            </span><br><span class="line">                 &#125;, </span><br><span class="line"></span><br><span class="line">                 @&#123;                               </span><br><span class="line">                    <span class="string">@"text"</span> : <span class="string">@"明天去旅游了"</span>, </span><br><span class="line">                    <span class="string">@"user"</span> : @&#123;                                                                   </span><br><span class="line">                                 <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                                       </span><br><span class="line">                                 <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>                               </span><br><span class="line">                               &#125;  </span><br><span class="line">                   &#125; </span><br><span class="line"></span><br><span class="line">                ],                       </span><br><span class="line"> <span class="string">@"ads"</span> :@[                           </span><br><span class="line">           @&#123;                               </span><br><span class="line">              <span class="string">@"image"</span> : <span class="string">@"ad01.png"</span>, </span><br><span class="line">              <span class="string">@"url"</span> : <span class="string">@"http://www.ad01.com"</span>                                                          </span><br><span class="line">            &#125;, </span><br><span class="line"></span><br><span class="line">           @&#123;                               </span><br><span class="line">              <span class="string">@"image"</span> : <span class="string">@"ad02.png"</span>,                                   </span><br><span class="line">              <span class="string">@"url"</span> : <span class="string">@"http://www.ad02.com"</span>                           </span><br><span class="line">            &#125;                       </span><br><span class="line">          ],                       </span><br><span class="line"> <span class="string">@"totalNumber"</span> : <span class="string">@"2014"</span>                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将字典转为StatusResult模型</span></span><br><span class="line">         StatusResult *result = [StatusResult objectWithKeyValues:dict];</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"totalNumber=%@"</span>, result.totalNumber);</span><br><span class="line">         <span class="comment">// totalNumber=2014</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 打印statuses数组中的模型属性</span></span><br><span class="line">         <span class="keyword">for</span> (Status *status <span class="keyword">in</span> result.statuses) &#123;    </span><br><span class="line">                <span class="built_in">NSString</span> *text = status.text;    </span><br><span class="line">                <span class="built_in">NSString</span> *name = status.user.name;    <span class="built_in">NSString</span> *icon = status.user.icon;    </span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"text=%@, name=%@, icon=%@"</span>, text, name, icon);&#125;</span><br><span class="line">               <span class="comment">// text=今天天气真不错！, name=Rose, icon=nami.png</span></span><br><span class="line">               <span class="comment">// text=明天去旅游了, name=Jack, icon=lufy.png</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 打印ads数组中的模型属性</span></span><br><span class="line">         <span class="keyword">for</span> (Ad *ad <span class="keyword">in</span> result.ads) &#123;    </span><br><span class="line">                 <span class="built_in">NSLog</span>(<span class="string">@"image=%@, url=%@"</span>, ad.image, ad.url);&#125;</span><br><span class="line">                 <span class="comment">// image=ad01.png, url=http://www.ad01.com</span></span><br><span class="line">                 <span class="comment">// image=ad02.png, url=http://www.ad02.com</span></span><br></pre></td></tr></table></figure><h5 id="核心代码3："><a href="#核心代码3：" class="headerlink" title="核心代码3："></a>核心代码3：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模型内部实现+ (<span class="built_in">NSDictionary</span> *)objectClassInArray方法</span><br><span class="line"></span><br><span class="line">[StatusResult objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="4-模型中的属性名和字典中的key不相同-或者需要多级映射"><a href="#4-模型中的属性名和字典中的key不相同-或者需要多级映射" class="headerlink" title="4. 模型中的属性名和字典中的key不相同(或者需要多级映射)"></a>4. 模型中的属性名和字典中的key不相同(或者需要多级映射)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bag</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> price;<span class="keyword">@end</span><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *ID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *desc;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *nowName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *oldName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *nameChangedTime;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Bag *bag;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="comment">// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)replacedKeyFromPropertyName&#123;    </span><br><span class="line">     <span class="keyword">return</span> @&#123;                </span><br><span class="line">               <span class="string">@"ID"</span> : <span class="string">@"id"</span>,                </span><br><span class="line">               <span class="string">@"desc"</span> : <span class="string">@"desciption"</span>,                </span><br><span class="line">               <span class="string">@"oldName"</span> : <span class="string">@"name.oldName"</span>, </span><br><span class="line">               <span class="string">@"nowName"</span> : <span class="string">@"name.newName"</span>,  </span><br><span class="line">               <span class="string">@"nameChangedTime"</span> : <span class="string">@"name.info.nameChangedTime"</span>,                                       </span><br><span class="line">               <span class="string">@"bag"</span> : <span class="string">@"other.bag"</span>            </span><br><span class="line">              &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;                       </span><br><span class="line">                        <span class="string">@"id"</span> : <span class="string">@"20"</span>,                       </span><br><span class="line">                        <span class="string">@"desciption"</span> : <span class="string">@"孩子"</span>,</span><br><span class="line">                        <span class="string">@"name"</span> : @&#123;                                                         </span><br><span class="line">                                     <span class="string">@"newName"</span> : <span class="string">@"lufy"</span>, </span><br><span class="line">                                     <span class="string">@"oldName"</span> : <span class="string">@"kitty"</span>,  </span><br><span class="line">                                     <span class="string">@"info"</span> : @&#123;                                                                                                   </span><br><span class="line">                                                  <span class="string">@"nameChangedTime"</span> : <span class="string">@"2013-08"</span>                            </span><br><span class="line">                                                 &#125;                       </span><br><span class="line">                                    &#125;,                       </span><br><span class="line">                        <span class="string">@"other"</span> : @&#123;                            </span><br><span class="line">                                      <span class="string">@"bag"</span> : @&#123;                                </span><br><span class="line">                                                  <span class="string">@"name"</span> : <span class="string">@"小书包"</span>, </span><br><span class="line">                                                  <span class="string">@"price"</span> : @<span class="number">100.7</span>                                                              </span><br><span class="line">                                                 &#125;                       </span><br><span class="line">                                     &#125;                   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为Student模型</span></span><br><span class="line">Student *stu = [Student objectWithKeyValues:dict];</span><br><span class="line"><span class="comment">// 打印Student模型的属性</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@"</span>, stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);</span><br><span class="line"><span class="comment">// ID=20, desc=孩子, oldName=kitty, nowName=lufy, nameChangedTime=2013-08</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"bagName=%@, bagPrice=%f"</span>, stu.bag.name, stu.bag.price);</span><br><span class="line"><span class="comment">// bagName=小书包, bagPrice=100.700000</span></span><br></pre></td></tr></table></figure><h5 id="核心代码4："><a href="#核心代码4：" class="headerlink" title="核心代码4："></a>核心代码4：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模型内部实现+ (<span class="built_in">NSDictionary</span> *)replacedKeyFromPropertyName方法</span><br><span class="line"></span><br><span class="line">[Student objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="5-将一个字典数组转成模型数组"><a href="#5-将一个字典数组转成模型数组" class="headerlink" title="5. 将一个字典数组转成模型数组"></a>5. 将一个字典数组转成模型数组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *dictArray = @[                       </span><br><span class="line">                        @&#123;                           </span><br><span class="line">                           <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                           </span><br><span class="line">                           <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>,                        </span><br><span class="line">                         &#125;,                       </span><br><span class="line">                        @&#123;                           </span><br><span class="line">                           <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,                           </span><br><span class="line">                           <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>,                        </span><br><span class="line">                         &#125;                    </span><br><span class="line">                       ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典数组转为User模型数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *userArray = [User objectArrayWithKeyValuesArray:dictArray];</span><br><span class="line"><span class="comment">// 打印userArray数组中的User模型属性</span></span><br><span class="line"><span class="keyword">for</span> (User *user <span class="keyword">in</span> userArray) &#123;   </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"name=%@, icon=%@"</span>, user.name, user.icon);&#125;</span><br><span class="line">      <span class="comment">// name=Jack, icon=lufy.png</span></span><br><span class="line">      <span class="comment">// name=Rose, icon=nami.png</span></span><br></pre></td></tr></table></figure><h5 id="核心代码5："><a href="#核心代码5：" class="headerlink" title="核心代码5："></a>核心代码5：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User objectArrayWithKeyValuesArray:dictArray]</span><br></pre></td></tr></table></figure><h4 id="6-将一个模型转成字典"><a href="#6-将一个模型转成字典" class="headerlink" title="6. 将一个模型转成字典"></a>6. 将一个模型转成字典</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建模型</span></span><br><span class="line">  User *user = [[User alloc] init];</span><br><span class="line">user.name = <span class="string">@"Jack"</span>;</span><br><span class="line">user.icon = <span class="string">@"lufy.png"</span>;</span><br><span class="line"></span><br><span class="line">Status *status = [[Status alloc] init];</span><br><span class="line">status.user = user;</span><br><span class="line">status.text = <span class="string">@"今天的心情不错！"</span>;</span><br></pre></td></tr></table></figure><p>​<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将模型转为字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *statusDict = status.keyValues;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, statusDict);</span><br><span class="line"><span class="comment">/*&#123; text = "今天的心情不错！";    </span></span><br><span class="line"><span class="comment">    user = &#123;        </span></span><br><span class="line"><span class="comment">             icon = "lufy.png";        </span></span><br><span class="line"><span class="comment">             name = Jack;    </span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级映射的模型</span></span><br><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu.ID = <span class="string">@"123"</span>;</span><br><span class="line">stu.oldName = <span class="string">@"rose"</span>;</span><br><span class="line">stu.nowName = <span class="string">@"jack"</span>;</span><br><span class="line">stu.desc = <span class="string">@"handsome"</span>;</span><br><span class="line">stu.nameChangedTime = <span class="string">@"2018-09-08"</span>;</span><br><span class="line"></span><br><span class="line">Bag *bag = [[Bag alloc] init];</span><br><span class="line">bag.name = <span class="string">@"小书包"</span>;</span><br><span class="line">bag.price = <span class="number">205</span>;</span><br><span class="line">stu.bag = bag;</span><br><span class="line"><span class="built_in">NSDictionary</span> *stuDict = stu.keyValues;<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, stuDict);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;    desciption = handsome;    </span></span><br><span class="line"><span class="comment">       id = 123;    </span></span><br><span class="line"><span class="comment">       name = &#123;        </span></span><br><span class="line"><span class="comment">                info =&#123;            </span></span><br><span class="line"><span class="comment">                nameChangedTime = "2018-09-08";        </span></span><br><span class="line"><span class="comment">                       &#125;;        </span></span><br><span class="line"><span class="comment">                newName = jack;        </span></span><br><span class="line"><span class="comment">                oldName = rose;    </span></span><br><span class="line"><span class="comment">               &#125;;    </span></span><br><span class="line"><span class="comment">                other = &#123;  </span></span><br><span class="line"><span class="comment">                          bag =&#123;            </span></span><br><span class="line"><span class="comment">                                 name = "小书包";            </span></span><br><span class="line"><span class="comment">                                 price = 205;        </span></span><br><span class="line"><span class="comment">                               &#125;;    </span></span><br><span class="line"><span class="comment">                        &#125;; </span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h5 id="核心代码6："><a href="#核心代码6：" class="headerlink" title="核心代码6："></a>核心代码6：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status.keyValues、stu.keyValues</span><br></pre></td></tr></table></figure><h4 id="7-将一个模型数组转成字典数组"><a href="#7-将一个模型数组转成字典数组" class="headerlink" title="7. 将一个模型数组转成字典数组"></a>7. 将一个模型数组转成字典数组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建模型数组</span></span><br><span class="line">  User *user1 = [[User alloc] init];</span><br><span class="line">user1.name = <span class="string">@"Jack"</span>;</span><br><span class="line">user1.icon = <span class="string">@"lufy.png"</span>;</span><br><span class="line"></span><br><span class="line">User *user2 = [[User alloc] init];</span><br><span class="line">user2.name = <span class="string">@"Rose"</span>;</span><br><span class="line">user2.icon = <span class="string">@"nami.png"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *userArray = @[user1, user2];</span><br><span class="line"><span class="comment">// 将模型数组转为字典数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *dictArray = [User keyValuesArrayWithObjectArray:userArray];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dictArray);</span><br><span class="line"><span class="comment">/*(    </span></span><br><span class="line"><span class="comment">&#123;        icon = "lufy.png";        name = Jack;    &#125;,    </span></span><br><span class="line"><span class="comment">&#123;        icon = "nami.png";        name = Rose;    &#125;  )*/</span></span><br></pre></td></tr></table></figure><h6 id="核心代码7："><a href="#核心代码7：" class="headerlink" title="核心代码7："></a>核心代码7：</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User keyValuesArrayWithObjectArray:userArray]</span><br></pre></td></tr></table></figure><h4 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考<span class="built_in">NSObject</span>+MJKeyValue.h</span><br><span class="line">参考<span class="built_in">NSObject</span>+MJCoding.h</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UIScrollView的代理方法汇总</title>
      <link href="/2019-02-02-ios-uiscrollview-delegate-methods/"/>
      <url>/2019-02-02-ios-uiscrollview-delegate-methods/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIScrollViewDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// any offset changes 只要scrollView的content 这个方法在任何方式触发 contentOffset </span></span><br><span class="line"><span class="comment">// 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset </span></span><br><span class="line"><span class="comment">// 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called on start of dragging (may require some time and or distance to move)</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// 用户开始拖动 scroll view 的时候被调用，可能需要一些时间和距离移动之后才会触发。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called on finger up if the user dragged. velocity is in points/millisecond. </span></span><br><span class="line"><span class="comment">// targetContentOffset may be changed to adjust where the scroll view comes to rest</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line"><span class="comment">// 在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero</span></span><br><span class="line"><span class="comment">//（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，</span></span><br><span class="line"><span class="comment">//willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，</span></span><br><span class="line"><span class="comment">// 当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，</span></span><br><span class="line"><span class="comment">// 减速直到 targetContentOffset。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate;</span><br><span class="line"><span class="comment">// 在用户结束拖动后被调用，decelerate 为 YES 时，</span></span><br><span class="line"><span class="comment">// 结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，</span></span><br><span class="line"><span class="comment">// scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，</span></span><br><span class="line"><span class="comment">// 所以这个 dragging 属性的实际语义更接近 scrolling。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;   <span class="comment">// 减速动画开始前被调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;      </span><br><span class="line"><span class="comment">// 减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，</span></span><br><span class="line"><span class="comment">// didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES。</span></span><br><span class="line"><span class="comment">// 新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；</span></span><br><span class="line"><span class="comment">// 如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用      </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidZoom:(<span class="built_in">UIScrollView</span> *)scrollView <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2); </span><br><span class="line"><span class="comment">// any zoom scale changes view缩放改变的时候调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)viewForZoomingInScrollView:(<span class="built_in">UIScrollView</span> *)scrollView;     </span><br><span class="line"><span class="comment">// return a view that will be scaled. if delegate returns nil, nothing happens</span></span><br><span class="line">告诉代理要缩放那个控件。 </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginZooming:(<span class="built_in">UIScrollView</span> *)scrollView withView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2); </span><br><span class="line"><span class="comment">// called before the scroll view begins zooming its content缩放开始的时候调用</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndZooming:(<span class="built_in">UIScrollView</span> *)scrollView withView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view atScale:(<span class="built_in">CGFloat</span>)scale; </span><br><span class="line"><span class="comment">// scale between minimum and maximum. called after any 'bounce' animations缩放完毕的时候调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView;   <span class="comment">// return a yes if you want to scroll to the top. if not defined, assumes YES- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;      </span></span><br><span class="line"><span class="comment">// called when scrolling animation finished. may be called immediately if already at top滚动动画完成时调用。</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UILabel的lineBreakMode省略模式设置</title>
      <link href="/2019-02-01-ios-uilabel-linebreakmode-setting/"/>
      <url>/2019-02-01-ios-uilabel-linebreakmode-setting/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByCharWrapping</span>; <span class="comment">//以字符为显示单位显示，后面部分省略不显示。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByClipping</span>; <span class="comment">//剪切与文本宽度相同的内容长度，后半部分被删除。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingHead</span>; <span class="comment">//前面部分文字以……方式省略，显示尾部文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingMiddle</span>; <span class="comment">//中间的内容以……方式省略，显示头尾的文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingTail</span>; <span class="comment">//结尾部分的内容以……方式省略，显示头的文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByWordWrapping</span>; <span class="comment">//以单词为显示单位显示，后面部分省略不显示。</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS修改UIImage图片尺寸大小逻辑分辨率</title>
      <link href="/2019-02-01-ios-uiimage-resize/"/>
      <url>/2019-02-01-ios-uiimage-resize/</url>
      
        <content type="html"><![CDATA[<p>之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)imageResize:(<span class="built_in">UIImage</span>*)img andResizeTo:(<span class="built_in">CGSize</span>)newSize &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = [[<span class="built_in">UIScreen</span> mainScreen]scale];</span><br><span class="line">    <span class="comment">//UIGraphicsBeginImageContext(newSize);</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(newSize, <span class="literal">NO</span>, scale);</span><br><span class="line">    [img drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,newSize.width,newSize.height)];</span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来就能使tabbar item的图标始终是25pt*25pt，恰到好处。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">childController.tabBarItem.selectedImage = [[SmallTools imageResize:[<span class="built_in">UIImage</span> imageNamed:selected] andResizeTo:<span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">25</span>)] imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>];</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1549072293345_888x213.gif" alt></p><h3 id="另外关于上图中间图标的动画效果实现可参考此文章"><a href="#另外关于上图中间图标的动画效果实现可参考此文章" class="headerlink" title="另外关于上图中间图标的动画效果实现可参考此文章"></a>另外关于上图中间图标的动画效果实现可参考此文章</h3><p><a href="http://paaatrick.com/ios_uitabbar_touch_animation.html" title="iOS UITabbar图标点击动画效果实现">iOS UITabbar图标点击动画效果实现</a>      </p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UITabbar图标点击动画效果实现</title>
      <link href="/2019-02-01-ios-uitabbar-touch-animation/"/>
      <url>/2019-02-01-ios-uitabbar-touch-animation/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： </p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>通过<code>tabBar: didSelectItem:</code>代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 </p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 </p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><blockquote><p>第二种方法：只对image执行动画 </p></blockquote><p>1、带重力效果的弹跳</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1549072293345_888x213.gif" alt></p><a id="more"></a><blockquote><p>后4个是第一种方法</p></blockquote><p>2、先放大，再缩小 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116103844396-1872210226.gif" alt></p><p>3、Z轴旋转 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116103932614-876709799.gif" alt></p><p>4、Y轴位移 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116104000302-95725194.gif" alt></p><p>5、放大并保持 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116104036224-920525159.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="获取要执行动画的Item"><a href="#获取要执行动画的Item" class="headerlink" title="获取要执行动画的Item"></a>获取要执行动画的Item</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MainTabbarVC</span> ()&lt;<span class="title">UITabBarControllerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span>  indexFlag;　　<span class="comment">//记录上一次点击tabbar，使用时，记得先在init或viewDidLoad里 初始化 = 0</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法：通过接收点击事件对每个tabbar item的点击都执行动画</span></span><br><span class="line">-(<span class="keyword">void</span>)tabBar:(<span class="built_in">UITabBar</span> *)tabBar didSelectItem:(<span class="built_in">UITabBarItem</span> *)item&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> index = [<span class="keyword">self</span>.tabBar.items indexOfObject:item];</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="keyword">self</span>.indexFlag) &#123;</span><br><span class="line">        <span class="comment">//执行动画</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arry = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *btn <span class="keyword">in</span> <span class="keyword">self</span>.tabBar.subviews) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([btn isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButton"</span>)]) &#123;</span><br><span class="line">                 [arry addObject:btn];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加动画</span></span><br><span class="line">　　　　 <span class="comment">//---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可---</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.indexFlag = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法：只想对某一个item的点击执行动画，且只有图片动，文字不动。并且其余图标的点击不带动画</span></span><br><span class="line">- (<span class="keyword">void</span>)tabBarImageAnimation &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIControl</span> *tabBarButton <span class="keyword">in</span> <span class="keyword">self</span>.tabBar.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([tabBarButton isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButton"</span>)]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UIControl</span> *tabBarButtonLabel <span class="keyword">in</span> tabBarButton.subviews) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([tabBarButtonLabel isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButtonLabel"</span>)]) &#123;</span><br><span class="line">                    <span class="built_in">UILabel</span> *label = (<span class="built_in">UILabel</span> *)tabBarButtonLabel;</span><br><span class="line">                    <span class="comment">//"tab1"到"tab4"分别是不打算执行动画的tabbar item的标题名称</span></span><br><span class="line">                    <span class="keyword">if</span> (![label.text isEqualToString:<span class="string">@"tab1"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab2"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab3"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab4"</span>]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">UIView</span> *imageView <span class="keyword">in</span> tabBarButton.subviews) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ([imageView isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarSwappableImageView"</span>)]) &#123;</span><br><span class="line">                                <span class="comment">//添加动画</span></span><br><span class="line">                                <span class="comment">//---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可---</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法的用法比较灵活，比如可以在TabbarVC里设上面<code>tabBarImageAnimation</code>方法的通知Observer，在需要执行动画的地方比如打开某VC时在该VC的<code>viewDidAppear</code>里post通知即可。</p></blockquote><h3 id="动画代码"><a href="#动画代码" class="headerlink" title="动画代码"></a>动画代码</h3><p>1、带重力效果的弹跳</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.y"</span>];</span><br><span class="line"><span class="comment">//通过初中物理重力公式计算出的位移y值数组</span></span><br><span class="line">animation.values = @[@<span class="number">0.0</span>, @<span class="number">-4.15</span>, @<span class="number">-7.26</span>, @<span class="number">-9.34</span>, @<span class="number">-10.37</span>, @<span class="number">-9.34</span>, @<span class="number">-7.26</span>, @<span class="number">-4.15</span>, @<span class="number">0.0</span>, @<span class="number">2.0</span>, @<span class="number">-2.9</span>, @<span class="number">-4.94</span>, @<span class="number">-6.11</span>, @<span class="number">-6.42</span>, @<span class="number">-5.86</span>, @<span class="number">-4.44</span>, @<span class="number">-2.16</span>, @<span class="number">0.0</span>];</span><br><span class="line">animation.duration = <span class="number">0.8</span>;</span><br><span class="line">animation.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1</span>;</span><br><span class="line">[imageView.layer addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>2、先放大，再缩小</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放大效果，并回到原位</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.autoreverses = <span class="literal">YES</span>;    <span class="comment">//完成动画后会回到执行动画之前的状态</span></span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.7</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.3</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>3、Z轴旋转</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//z轴旋转180度</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">YES</span>;</span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:M_PI];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>4、Y轴位移</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上移动</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.y"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">YES</span>;</span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">-10</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>5、放大并保持</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放大效果</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">animation.fillMode = kCAFillModeForwards;           <span class="comment">//保证动画效果延续</span></span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.15</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//移除其他tabbar的动画</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arry.count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != index) &#123;</span><br><span class="line">        [[arry[i] layer] removeAllAnimations];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，如果想定制其他动画效果，还可以从下面属性里自己定制动画 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116093610724-1578979553.png" alt></p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比咪蒙更可怕的，是挖祖坟式举报清算</title>
      <link href="/2019-02-01-raistlin2017/"/>
      <url>/2019-02-01-raistlin2017/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文始发于微信公众号（为你写一个故事）：<a href="http://mp.weixin.qq.com/s/Xb4bgA_2ylXRwQO4isgJqg" target="_blank" rel="noopener">比咪蒙更可怕的，是挖祖坟式举报清算</a></p></blockquote><p>因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。  </p><a id="more"></a><p>就事论事的说，才华有限青年其实和咪蒙关系不大，那确实是个相对独立的团队，我也读过他们以前很多文章，很多都挺好看，要说有什么错，最多是有点煽动情绪。  </p><p>但是做媒体嘛，又有几个不煽动情绪呢，只要不造谣，不引导邪恶的价值观，就没啥问题。  </p><p>所以我觉得一个好的方式是，你不同意她的一篇文章，就说这篇文章写得不好写得不对，甚至可以说这篇文章写得用心险恶。  </p><p>但你去挖她的出身，说她以前是咪蒙的实习生，所以一定不是什么好人。  </p><p>就有点恶毒了。  </p><p>比如有一位我挺喜欢的媒体人，这样写，我就觉得恶毒了  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951367.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>（而且如果真的翻了照片的话，较真的说这句话是造谣）  </p><p>还有昨天整个朋友圈轰轰烈烈的”含咪量“测试，很多人号称朋友圈只要有人关注咪蒙了，就要和TA互删。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951367.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/9-1548951368.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"><br>这我也觉得太过。<br>按照他们的意思，也别管这人是谁，和他们是什么关系，是不是好朋友或者亲戚，也不管这个人关注咪蒙究竟是认同咪蒙的价值观还是就想围观一下或者学习排版，只要关注咪蒙，就要互删。<br>这放在几十年前，我们叫做”划清界限“，流行这种运动的十年，是新中国最混乱的十年。<br>当然我觉得更过的，还是下面这张截图。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951370.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>咪蒙一边说这话，一边”永远爱国，永远热泪盈眶“恶不恶心？<br>恶心。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951372.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"><br>咪蒙式毒鸡汤讨不讨厌？  </p><p>我也讨厌。<br>但这样挖祖坟式清算举报，尤其是一直翻到2013年的微博，然后把相关机构全都@一遍的行为，让我感到很不舒服。<br>这种不舒服不是反感，而是感到恐怖。<br>而且这样的事情，这些年越来越多了。<br>这样的待遇，陈一发遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/9-1548951373.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>罗永浩遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951373.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>毕福剑也遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951374.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>普通网友当然也遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951375.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>动不动就呼吁封杀，虎扑和吴亦凡粉丝战斗时，双方都遭遇过。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951377.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951379.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>游戏《阴阳师》遭遇过：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951380.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>明星骂战的时候使用过这种武器。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/10-1548951381.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>社会热点事件就不说了，总是有成千上万人向团团举报。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951383.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>现在甚至王者荣耀玩得不爽了，也要举报。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951383.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>在这些举报里，网友们用不知道从哪里学到的词汇，给自己看着不爽的人扣上一个又一个大帽子，套上一个又一个罪名，其手法之纯熟，让我一度以为生活在冯骥才的《一百个人的十年》里。</p><p>可惜拿起手机瞧一瞧，发现已经是2019年了。</p><p>在我看来这种行为和看到让自己不爽的综艺，歌曲，电影就呼吁封杀是一样的，都是分不清各种权利界限的表现。就像几百年前，被人欺负了，就去衙门一跪，高喊“大人，我冤啊！”，然后期待青天大老爷给自己做主的古代中国人一样，始终没有长大。</p><p>他们自己是巨婴，却以为我国居民全都是长不大的巨婴，需要妈妈无微不至地照顾我们，帮我们挑好哪些是我们该看的，哪些是我们不该看的，然后只要他们看到自己不爽的，就会像孩子一样哭喊着叫妈妈来，希望妈妈把“坏东西”都打飞，然后才会重新喜笑颜开。</p><p>可惜现代法制社会没有，也不应该有青天大老爷——历史早已经证明了，青天大老爷式的人治，远不如法治来得公平高效，青天大老爷十年一遇，但手握权力，肆意滥用的昏官却遍地都是。  </p><p>这已经很魔幻了。</p><p>但更魔幻的是，这些诉求，有时候还真的会得到回应。</p><p>以前我觉得孩子长不大，站不起来，是因为孩子自己笨，不想长大，后来才明白，孩子长不大，多半是有一个什么都替孩子做主，什么都替孩子决定的妈——在这些挖坟举报真的会得到回应的情况下，这样的行为永远不会停止，只会变本加厉。</p><p>即使如此，我还是希望你们能少挖坟，少呼吁封杀。</p><p>因为“封杀”这个词代表的那个行为，本来就不应该存在于这个世界上，并且当你习惯”封杀“之后，迟早有一天，会降临到你喜欢的那个账号，那个主播或者那个明星身上。</p><p>还记得之前整治八卦的时候吗？  </p><p>一开始封的很多账号，大家都讨厌，所以一片叫好声。结果之后发展到只要账号中带”八卦“两个字的，都被封号了，包括大家爱看的”毒舌电影“，”严肃八卦“，”金融八卦女“也全部都凉了。</p><p>最搞笑的是，我有个朋友，做了个账号叫”财经八卦阵“，那段时间只能改成”财经九卦阵“，终于躲过一劫。</p><p>还记得之前讨厌PGONE的人拼命举报PGONE，@了一大堆官方账号，要求对PGONE进行封杀吗？</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951384.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951385.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951385.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951386.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>那会儿恰好GAI求婚成功，所以当时这些人中，有不少都人是通过捧GAI来踩PGONE的。</p><p>我自己也是GAI的粉丝，在一个GAI的粉丝群里，有几个姐们表示太好了，解气。但随即更多人表示这不是好事，因为GAI也有黑历史。</p><p>果然过了没多久，GAI被迫从《歌手》中退赛，至今也没在电视上再看过他。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951386.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>在这样轰轰烈烈的挖坟式举报运动中，暴走漫画凉了，陈一发凉了，卢本伟凉了，毕福剑凉了，很多歌手明星都凉了。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951387.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><strong>PGONE被封杀你们叫好，GAI被封杀你们喊冤，毕福剑从央视消失你们想念他。你们以为这几件事不一样应该分开，但经历过这么多事情，你们应该明白，这两件事其实根本就是一件事。</strong>  </p><p>封杀的人不会管哪个嘻哈歌手是正能量的，哪个是屡教不改的——既然嘻哈有问题，那就有问题的一起下。</p><p>就像现在这些为咪蒙的倒台拍手叫好的自媒体人，你又知道封杀的人分得清你和咪蒙的区别咯？</p><p>况且在我看来，很多账号根本就和咪蒙没区别。</p><p>比如某个自媒体，洋洋洒洒写了几千字，细数咪蒙的”七宗罪“。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951388.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>最后得出的结论是，咪蒙最大的罪就是她在迎合读者，并且标题低俗，危害极大。他把文章发到500人的新媒体群里，希望大家为他鼓掌叫好。</p><p>结果翻开他自己的公众号，标题却是这个画风的。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951390.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>当有人在群里质问他，这是不是在迎合读者，标题低俗，危害极大的时候，他很坦诚的承认”可我的没人看啊。“</p><p>让人心慌。</p><p>一个事实是，我们说的法制说的正义，从来不是给我们喜欢的东西准备的，我们喜欢的东西，根本不需要心中的那杆称来保护。  </p><p>我们说的正义和法制，是你们讨厌的人，也有说话的权利，如果他们没有违法，就不应该不让他们说话。</p><p>还有一个事实是，咪蒙的价值观确实有问题，也许能煽动几十万人的情绪，是会让人焦虑，但真要说她改变了多少人三观，我觉得各位是高看文字的力量了。</p><p>一方面咪蒙并不产生三观，她一般只迎合大众情绪，另一方面三观这东西是没那么容易改变的，2019年了，文字早就没那么大力量了，现在如果说谁因为一篇文章三观就变了，那说明TA本来就有这样的想法，只是这篇文章正好支持了TA而已。</p><p>比起咪蒙，我更害怕那样因为讨厌一个人，就肆无忌惮地爆粗口，就想着要弄死对方，更害怕那样挖祖坟式的举报。</p><p>因为这让我觉得自己每时每刻都活在监视中，终日不得安宁。</p><p>现在你们觉得应该这样对付咪蒙，谁知道哪天我会不会受到这样的待遇。</p><p>而且说一千道一万，当年咪蒙写那几篇文章，疯狂在朋友圈转发刷屏，把咪蒙一度捧成微信第一大号的，还不是网友吗？</p><p>看到某个去年还把咪蒙请为座上宾，一口一个咪蒙老师做分享的机构，昨天他们主编也开始测含咪率了，可能下一步就要表态”互删“了。</p><p>看到之前分享过致贱人几篇的人，开始在朋友圈说”想不通为什么这么多人会关注咪蒙“了。</p><p>有时候见多了这种昨天还万人追捧，今天就过街老鼠的戏码。真是让人对这个复杂繁复的世界，又害怕了几分呢。</p><p>-END-</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>亲测真正好用的WordPress媒体库图片分类插件</title>
      <link href="/2019-01-31-wp-real-media-library/"/>
      <url>/2019-01-31-wp-real-media-library/</url>
      
        <content type="html"><![CDATA[<p>WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.12.21.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.12.51.png" alt></p><p>然而实际使用起来极不方便，上传图片时不能选择上传到哪个分类，现有的图片也不能多选设置分类，需要点开每一张图片再勾选分类。 然后找到一个 WP Real Media Library 度娘盘找到了资源，下载后在WordPress插件界面上传使用。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.01.56.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.13.26.png" alt></p><p>使用起来非常顺手。</p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a><a href="http://www.4mudi.com/themes/wp-real-media-library/#toggle-id-2" title="下载链接" target="_blank" rel="noopener">下载链接</a></h3><h3 id="V4-0-10-度盘链接"><a href="#V4-0-10-度盘链接" class="headerlink" title="V4.0.10 度盘链接"></a><a href="https://pan.baidu.com/s/1W5AYA0jVPFWZwZMmHMYd4w" title="V4.0.10 度盘链接" target="_blank" rel="noopener">V4.0.10 度盘链接</a></h3>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器使用WordPress搭建个人博客并绑定域名全记录</title>
      <link href="/2019-01-29-build-wordpress-blog/"/>
      <url>/2019-01-29-build-wordpress-blog/</url>
      
        <content type="html"><![CDATA[<p>一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。</p><h3 id="关于服务器"><a href="#关于服务器" class="headerlink" title="关于服务器"></a><strong>关于服务器</strong></h3><p>前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.26.19.png" alt> </p><a id="more"></a><h4 id="安装-Apache2、MySQL、PHP"><a href="#安装-Apache2、MySQL、PHP" class="headerlink" title="安装 Apache2、MySQL、PHP"></a><strong>安装 Apache2、MySQL、PHP</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p>测试一下Apache2是否成功安装：浏览器访问云服务器的IP，安装成功的话会显示Apache2的默认页面，It works。   安装php7.0，并安装apache的php扩展，再安装整合mysql和php的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0</span><br><span class="line">sudo apt-get install libapache2-mod-php7.0</span><br><span class="line">sudo apt-get install php7.0-mysql</span><br></pre></td></tr></table></figure><p>重启一下Apache2和MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><p>安装 phpmyadmin 这是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure><p>开启 apache 的 mod_rewrite，再重启一次apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><p>先登录mysql <code>mysql -u root -p</code> ，输入密码 首先创建名为“wordpressdb”数据库，然后查看创建的数据库是否成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database wordpressdb;</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>看到图中出现自己创建的数据库。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318165221370.png" alt>  </p><p>给用户服务权限，下面的wordpressuser改为安装mysql时自己输入的用户名。</p><p>GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;<br>FLUSH PRIVILEGES;</p><p>  输入 <code>exit;</code>退出mysql，并再次重启服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h4 id="下载并配置WordPress"><a href="#下载并配置WordPress" class="headerlink" title="下载并配置WordPress"></a><strong>下载并配置WordPress</strong></h4><p>用wget从WordPress官方网站下载安装包，放在 /var/www/html/ 目录，然后解压。 （最新版下载链接在 <a href="https://cn.wordpress.org/download/" target="_blank" rel="noopener">https://cn.wordpress.org/download/</a> 里面有）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/</span><br><span class="line">sudo wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.zip</span><br><span class="line">sudo tar zxf wordpress-4.9.4.tar.gz</span><br></pre></td></tr></table></figure><p>  在 /var/www/html/wordpress/wp-content/ 下创建uploads。 然后更改上传目录权限，不然之后博客上传不了图片。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir uploads</span><br><span class="line">sudo chown -R www-data /var/www/html/wordpress</span><br><span class="line">sudo chmod -R 755 /var/www/html/wordpress</span><br><span class="line">sudo chown -R :www-data /var/www/html/wordpress/wp-content/uploads</span><br></pre></td></tr></table></figure><p>  配置wp-config-sample.php ，该文件在/var/www/html/wordpress/下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi wp-config-sample.php</span><br></pre></td></tr></table></figure><p>修改方法如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318182134757.png" alt></p><p>浏览器访问  http://服务器IP地址/wordpress ，如果安装正常则进入wordpress的安装界面。 安装好后的效果如图： </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318182550961.png" alt></p><p>到此建站完成。接下来申请域名并绑定服务器。</p><h3 id="申请域名并配置DNS"><a href="#申请域名并配置DNS" class="headerlink" title="申请域名并配置DNS"></a><strong>申请域名并配置DNS</strong></h3><p>通过比价网站可以先大致看一下想要的域名价格 <a href="https://www.domcomp.com/" target="_blank" rel="noopener">https://www.domcomp.com/</a></p><p>看了一下知乎，大家推荐的域名供应商有 NameSilo 、Namecheap、Porkbun、GoDaddy等，亲测了一遍，发现 NameSilo 用户界面太丑；Namecheap 实际并不 cheap；最多人说的 GoDaddy 也偏贵但是支持支付宝，Porkbun 性价比高而且界面友好。 因为有境外支付的信用卡就不考虑 GoDaddy 了，直接在 Porkbun 上下单了一个 .com 域名，首年不到 7刀，续费 8.7刀。 </p><p>值得一提的是支付时好几张卡支付失败，建行、农行都不行，换了广发的万事达才支付成功，有点迷。 付款后主页可以看到自己域名的各种详情，然后要设置的是 DNS RECORDS </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.48.31.png" alt></p><p>点击Edit，添加两个A记录，分别是带www和不带的域名，ANSWER填自己的主机地址。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.50.38.png" alt></p><p>两个NS填DNS提供商的，这里因为Vultr自带了免费的DNS服务，直接填上去即可，具体的DNS地址可在Vultr的设置页里找。 下图就是设置页，可以看到底下有两条DNS地址，填到 Porkbun 里，然后还要在 Vultr 里 Add Domain，绑定服务器到域名。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.52.20.png" alt></p><p>两边都操作完成后，静候几分钟，然后访问一下自己的域名，应该就出来了。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><h4 id="在仪表盘的设置中不小心更改了wordpress地址后回不到后台"><a href="#在仪表盘的设置中不小心更改了wordpress地址后回不到后台" class="headerlink" title="在仪表盘的设置中不小心更改了wordpress地址后回不到后台"></a><strong>在仪表盘的设置中不小心更改了wordpress地址后回不到后台</strong></h4><p>在建站过程中，如果改动了 wordpress地址或站点地址，就回不到后台了。 </p><p>解决方法：网站首页在wordpress目录下的index.php中的require这行的内容。 </p><p>下图是wordpress下index.php的require所在行的内容。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319090603947.png" alt></p><p>最开始wordpress url是： 主机ip/wordpress。 它会自动去找index.php，然后就通过index.php里面的内容加载wordpress环境，更改了url后，就不能自动去找index.php了。此时后台也无法登录。解决这个问题，直接进数据库修改相关数据即可。操作如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p //然后输入密码</span><br><span class="line">show databases; //显示所有数据库</span><br><span class="line">use wordpressdb; //选中你自己网站对应的数据库。</span><br><span class="line">show tables; //显示该数据库所有表格。</span><br><span class="line">select * from wp_options where 1=1 limit 10; //查看数据库前10条记录</span><br><span class="line">update wp\_options set option\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;siteurl&apos;;//（如果home也改了就也改回来）</span><br><span class="line">update wp\_options set option\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;home&apos;;</span><br></pre></td></tr></table></figure><p>其实就是改变了wordpress url ，则wp_options表中的siteurl的值变化了，只要把它在修改过来就行。</p><h4 id="使用服务器IP（或域名）根地址直接访问网站首页"><a href="#使用服务器IP（或域名）根地址直接访问网站首页" class="headerlink" title="使用服务器IP（或域名）根地址直接访问网站首页"></a><strong>使用服务器IP（或域名）根地址直接访问网站首页</strong></h4><p>此文章的建站方法是把所有东西都放在wordpress目录下，因此建完后，访问网站的网址为：主机IP/wordpresss。</p><p>通常情况下，我们会买一个域名与云主机IP绑定，输入IP地址只能访问根目录。 即/var/www/html，但是无法访问其下面的子目录。</p><p>以下将给出解决方案。如果使主机IP直接定位到网站首页。</p><p>第一种解决方式是把wordpress的内容直接都弄到根目录中，这是不提倡的，会使根目录变得杂乱。通常推荐第二种方案。   </p><p>第二种方案操作如下： 登录后台，打开 设置→常规，修改站点地址。 </p><p>WordPress地址是本体存放的地址，按本文安装的话就不用改动了。 站点地址是浏览器访问的地址，改为 “http://服务器IP（或域名）” 的形式，如下图即可。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-15.26.26.png" alt></p><p>同时，打开 设置→固定链接，把固定链接修改成如下形式：（去掉中间的/wordpress/） </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.14.42.png" alt></p><p>至于文章后缀名，网上有关WordPress永久链接设置的介绍众多，普遍认为 <code>/%postname%.html</code> 是最佳的自定义永久链接形式。</p><p>这种形式将显示为:http://你的域名/日志标题.html，简单明了，有利于SEO。但当你的日志标题是中文时，文章标题以中文形式出现，看上去很不符合标准，或者可能会出现如:%64%b3%e8%ae%ar%e6%ba%a7%e5%9.html 类似乱码的显示。因此需要在编辑文章时，标题下面固定链接项，点击编辑，用拼音或英文输入文章标题。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.19.42.png" alt>  </p><p>然后把wordpress目录下的index.php 和 .htaccess文件复制一份到根目录下，.htaccess 是隐藏文件，可以使用ls -all。将其显示出来。注意是复制文件，原来目录下还存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/wordpress/</span><br><span class="line">cp index.php /var/www/html/</span><br><span class="line">cp .htaccess /var/www/html/</span><br></pre></td></tr></table></figure><p>然后使用vim修改.htaccess文件的内容为下图所示。（默认文件如果就是如此则跳过该步骤） </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319093058967.png" alt></p><p>修改index.php文件，因为index.php文件是wordpress下index.php的复制品，因此文件内部的require那一行的值当对于当前目录，是不正确的。同样使用vim编辑该文件，把require那一行路径，修改成下图那样。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319093423845.png" alt></p><p>此时再输入IP，看到还是It works界面，那是因为安装apache时，我们看到的It works界面其实是根目录下的index.html。当index.html 和 index.php同时存在时，默认还是打开index.html，所以应该把index.html移出该目录。我们把它移出到其他目录就行。  </p><h4 id="然后可能会产生下一个问题，设置固定链接后，文章页会404"><a href="#然后可能会产生下一个问题，设置固定链接后，文章页会404" class="headerlink" title="然后可能会产生下一个问题，设置固定链接后，文章页会404"></a><strong>然后可能会产生下一个问题，设置固定链接后，文章页会404</strong></h4><p>解决方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure><p>把 AllowOverride None 改为 AllowOverride ALL</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170922122312719.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170922122320129.png" alt></p><p>注意有两处要改，然后操作一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo /etc/init.d/apache2 restar</span><br></pre></td></tr></table></figure><p>刷新一下应该就能正常打开文章了。</p><h3 id="主页样式修改"><a href="#主页样式修改" class="headerlink" title="主页样式修改"></a><strong>主页样式修改</strong></h3><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170413090347184.jpeg" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170413090322305.png" alt></p><p>页尾和功能模块里的链接如果觉得碍眼，可以去除。  </p><h4 id="删除页尾“自豪地使用WordPress”字样"><a href="#删除页尾“自豪地使用WordPress”字样" class="headerlink" title="删除页尾“自豪地使用WordPress”字样"></a><strong>删除页尾“自豪地使用WordPress”字样</strong></h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.12.11.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.15.07.png" alt>  </p><p>如果是通过函数生成页尾的主题，一般在模板函数那里修改，查找 “Proudly powered by” 的字样删掉就ok。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=“&lt;?php echo esc\_url( \_\_( ‘http://wordpress.org/’, ‘twentyeleven’ )); ?&gt;” title=“&lt;?php esc\_attr\_e(‘SemanticPersonalPublishing Platform’, ‘twentyeleven’ ); ?&gt;” rel=“generator”&gt;&lt;?php printf( __( ‘Proudly powered by%s’,‘twentyeleven’ ), ‘WordPress’ ); ?&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress-org”"><a href="#删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress-org”" class="headerlink" title="删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”"></a><strong>删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”</strong></h4><p>打开组件文件夹：wp-include/widgets/class-wp-widget-meta.php 找到代码段删除即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!\-\-</span> 屏蔽 <span class="attr">RSS</span> 功能</span></span><br><span class="line">&lt;li&gt;&lt;a href="&lt;?php echo esc\_url( get\_bloginfo( 'rss2\_url' )); ?&gt;"&gt;&lt;?php \_e('Entries &lt;abbr title="Really Simple Syndication"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;?php echo esc\_url( get\_bloginfo( 'comments\_rss2\_url' )); ?&gt;"</span>&gt;</span>&lt;?php _e('Comments &lt;abbr title="Really Simple Syndication"&gt;RSS&lt;/abbr&gt;'); ?&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性冷淡商务风：深圳龙华希尔顿逸林酒店</title>
      <link href="/2017-05-17-doubletree-longhua/"/>
      <url>/2017-05-17-doubletree-longhua/</url>
      
        <content type="html"><![CDATA[<p>龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760825.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760828.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店">  </p><p>酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。   </p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760829.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>一进大堂就是典型的 DoubleTree 性冷淡风格，米白色大理石为主的装修风格使原本较小的大堂显得大气，前台人手不够，客人多时要排队 CI/CO，上酒廊 Check-in 就更是要等很久了。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760829.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760830.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760831.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店被设计在这栋楼底部十几层，上半部分是写字楼，似乎业主不太重视酒店。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760832.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店">  </p><p>这次入住时房态紧张，只给升一级到12楼的园景房，虽然没升级到行政房不过也给了行政待遇。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760833.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>DoubleTree 标志性的热曲奇饼，每位顾客入住时都给两份，很好吃，路过前台时可以再要几块。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760835.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760837.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760837.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760839.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760840.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>因为是新开业的酒店，硬件水准在同品牌中数一数二，客房面积48平方起步也没什么问题，套房楼层据说被某剧组包了几个月，因此没能升级套房挺可惜的。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760842.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760843.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760845.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>逸林标配单人浴缸，卫生间干湿分离，瑰珀翠（Crabtree &amp; Evelyn）的备品味道一般，还是更喜欢彼得罗夫（Peter Thomas Roth）的热情果味。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760846.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760847.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760848.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>窗外正对龙华文化广场，也是新建的，晚上有大批广场舞大妈，幸好玻璃隔音性能不错，问题是晚上有治安的单车持续闪烁红蓝灯光，穿透力极强，不拉上遮光窗帘要被闪瞎眼。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760850.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760852.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760853.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760855.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>床头音响支持直接插 iPhone 播放，插座自带USB也是这几年新开酒店的标配了。欢迎水果略显小气，进门的柜子另有玄机，水壶茶杯和小冰箱都藏在里面。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760855.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760856.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760857.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760859.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548760862.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760863.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>行政酒廊的 Happy Hour 从17点到19点，菜品十分丰富，热菜、甜品很多，当作晚餐完全没有问题。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760865.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760865.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760866.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760867.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店健身房还没装修好，把酒廊对面的一间套房改造成了一个临时健身房，所以面积很小，设备也不够多，来几个老外就占满了。室外泳池也要到17年5月底才开放。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760868.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760870.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>回到房间发现已经开好了夜床，可能是看到一下子把两瓶水喝完了，于是又补充了六瓶😂而且很贴心地在床上放了张明日天气预报。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548760872.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760874.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760875.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760876.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548760878.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760880.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760882.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760884.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店的主餐厅名为 『OPEN | “開”全日餐厅』，然而晚上只营业到22点，并没有通宵开放😑 早餐看似丰富，实际出品一般，蛋卷和鸡肉肠还没有希尔顿花园的好吃。不过餐厅环境确实不错，适合平时晚上来吃自助餐。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760885.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>这间 DoubleTree 最近几个月都不放基础房了，可能确实是商务客比较多吧， 10000分入住虽然没有华东一堆5000分 DoubleTree 那么白菜价，但毕竟地处深圳龙华腹地，性价比非常高，实属希尔顿保级优选。      </p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/3AVq0D4fRAt10VIMWOGvmw" target="_blank" rel="noopener">性冷淡商务风：深圳龙华希尔顿逸林酒店</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hotel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宜家 | 一个顺便卖卖家具的饭堂</title>
      <link href="/2015-12-17-ikea-canteen/"/>
      <url>/2015-12-17-ikea-canteen/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548761309.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>相信很多人印象中的宜家只是个卖家具的地方</p><p>跟自己关系不大</p><p>去那里干嘛</p><a id="more"></a><p>然而事实上并不是这样的  </p><p>宜家不只是卖家具</p><p>也卖非常多零碎玩意</p><p>很适合买来充实宿舍</p><p>但更重要的是它的餐厅</p><!-- more --><p>一个室友说</p><p>“宜家就是个顺便卖家具的食堂”</p><p>这话不假</p><p>这个餐厅不只是周末人满为患</p><p>即便是工作日也要找座位找很久</p><p>这还是宜家坐落在没有地铁经过的郊区的前提下</p><p>显得更为难得</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761310.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲餐厅门口菜单</p><p>餐厅不算太大</p><p>菜单也很简单</p><p>主菜也就瑞典肉圆 蔬菜丸 肉酱面 三文鱼 西冷牛扒 牛肉饭等</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761312.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>最赞的就是瑞典肉圆了</p><p>不同于汕头牛肉丸爽口 弹性 有嚼劲</p><p>宜家的瑞典肉圆口感细腻 用料丰富</p><p>以猪肉和牛肉混合搅碎</p><p>加入牛奶 面包糠 切碎的洋葱 马铃薯粉或燕麦片</p><p>然后再加上白胡椒 盐 五香粉或肉桂等香料调味</p><p>搓匀后捏成球形  </p><p>食用时配以肉酱 土豆泥 果酱以及一枚瑞典国旗  </p><p>令人食指大动</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548761313.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>西冷牛扒出品还算可以</p><p>虽然跟专门做牛扒的餐厅相比差距不小</p><p>但考虑到三十多的售价也能理解 还是值这个价的</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761314.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>烤三文鱼配通心粉</p><p>份量十足</p><p>不到三十块</p><p>价格感人</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548761316.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>奥尔良鸡腿</p><p>表皮烤的焦焦的</p><p>肉质多汁嫩滑</p><p>跟肉丸一样也是必点</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761318.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>冷盘菜</p><p>香草三文鱼</p><p>酸黄瓜酱不会掩盖三文鱼的鲜美</p><p>反而相得益彰美味可口</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548761319.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>宜家物价让人有种回到十年前的感觉</p><p>在深圳物价飞涨都快赶上香港的年代</p><p>还有这么个出品优良又便宜的餐厅实属不易</p><p>如果不是因为路途遥远交通不便利真的就成饭堂了</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761320.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲取菜窗口超像饭堂</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761323.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>说是饭堂的另一个原因</p><p>顾客吃完后需要自己把餐盘放进回收车里</p><p>大大减少清洁阿姨工作量</p><hr><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761325.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲会员卡颜值颇高</p><p>记得办一张宜家的会员卡</p><p>在入口和收银台前都有免费申请的电脑</p><p>填完资料直接就吐卡出来了</p><p>工作日凭会员卡可以在餐厅免费喝咖啡</p><p>无限续杯的喔</p><p>而且很多单品都有会员优惠</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548761327.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>比如这个两块九的杯子  </p><p>新会员可以一块钱购买</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761329.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761330.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>值得一提的是毛巾和门垫  </p><p>毛巾质量很好 不会掉毛</p><p>门垫价格感人</p><p>可以屯多几张在宿舍</p><p>脏了直接换一个</p><hr><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761331.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>在收银台出来的地方还有一个小食档</p><p>五块钱的热狗套餐可以无限续杯</p><p>最近饮料都换成了相比可乐含糖量减半的北欧风味果味饮料</p><p>不过感觉还是以前的蔓越莓果汁好喝</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761333.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>还有就是十块三串的墨鱼丸</p><p>真心赞赞赞赞赞</p><p>外焦里嫩弹牙可口</p><p>墨鱼味十足</p><p>买买买后吃上一份墨鱼丸真是酸爽</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761334.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>还有同样十块三串的烤肠  </p><p>味道跟乐凯撒的烤肠差不多</p><p>因为量不多</p><p>晚上七八点后可能就卖完了</p><p>同样强力推荐</p><p>见到了赶紧买三串</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761335.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>小食档旁边还有专门卖瑞典特产的超市</p><p>如果肉丸或者三文鱼吃的不过瘾还能买冷冻的回去自己煮</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761336.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>阻挡宜家成为饭堂的最大因素还是地理位置不好</p><p>公交非常不便利</p><p>只能自驾或者打车前往</p><p>不过不塞车的话从桂庙过去十分钟就能到</p><p>所以闲暇之余还是可以去吃餐饭的</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761337.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761337.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/fml6LiuDyC8qeY6rLNhtpw" target="_blank" rel="noopener">宜家 | 一个顺便卖卖家具的饭堂</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Food </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一蘭拉面</title>
      <link href="/2015-11-18-ichiran-ramen/"/>
      <url>/2015-11-18-ichiran-ramen/</url>
      
        <content type="html"><![CDATA[<p>一蘭拉面</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759254.jpeg" alt="一蘭拉面"><br>▲铜锣湾店门口 </p><p>一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。 </p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548759255.jpeg" alt="一蘭拉面"><br>▲座位都是一个个隔间 </p><p>年初的时候，一兰除了日本本土外就只有铜锣湾一家分店，港岛线铜锣湾站C出口走5分钟谢斐道440号门面便是。店铺不算大，目测只能容纳50人，天黑了之后一直到凌晨三四点都要排队，22点左右高峰期甚至要排一个钟的队，不过为了吃上一碗一兰拉面，排队久一点也值得。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759257.jpeg" alt="一蘭拉面"><br>▲铜锣湾店排队排出了店面   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759259.jpeg" alt="一蘭拉面"><br>▲空余座位展示，每个绿色格子代表一个座位 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548759262.jpeg" alt="一蘭拉面"><br>▲只有一款面的菜单 </p><p>排队快到的时候店员会给单你让你圈出偏好，我除了硬度喜欢偏硬一些外其他都是普通。偏硬是因为咬起来有口感。一碗89块港币的拉面，精华在于汤底，浓香而不腻，实打实用豚骨熬制，不加味精。吃完面后如果不喝汤就太浪费了。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759263.jpeg" alt="一蘭拉面"><br>▲1/2倍辣 </p><p>因为还是学生，钱不多，所以很少追加面底、温泉蛋、叉烧或者波子汽水。不过温泉蛋是真心好吃，建议尾巴们去的话一定要点一份。 秘制酱汁确实挺辣的，有一次被怂恿写了5倍辣，吃完整个人都不好了，当晚睡觉都睡不好。当然主要是因为我不太能吃辣，无辣不欢的尾巴可以试试20倍辣，很酸爽[doge] </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548759264.jpeg" alt="一蘭拉面"><br>▲5倍辣 </p><p>店面是单人隔间，每个位置都有冷水水龙头，就算再冷的天也是冷水。网上的解释是  </p><blockquote><p>冰水的作用在於吃拉面时缓和浓厚的味道，同时有助口腔降温加快吃面速度，因为面太热而吃得慢，面浸汤糊烂的情况只会越来越严重。 冰水是多年来日式拉面的传统，春夏秋冬也不改。博主曾在下雪日子在拉面店外排队，店员会为等待的人送上热茶，但去到店内还是冰水。 希望大家不要因為气温10度时拉面店内送上冰水就破口大骂或上网劣评，人家日本人下雪时都未投诉。理解这原因后仍想要热水的话，向店员礼貌地要求就是了。</p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548759265.jpeg" alt="一蘭拉面"><br>▲每个座位上都有首次来店顾客指南，中英日各一份 </p><p>今年年中的时候，一兰在尖沙咀棉登径8号负一楼开了第二家分店。不知道什么原因，很多地图上都还没有标记出来，尖沙咀N4出口出来就是了。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759265.jpg" alt="一蘭拉面"><br>▲高德地图 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759267.jpeg" alt="一蘭拉面"><br>▲尖沙咀店入口，店铺在负一楼 </p><p>可能是因为在铜锣湾的第一家海外分店尝到了甜头，这家新分店面积很大，而且出现了一兰屋台，就是普通餐厅的座椅区，但我还是喜欢隔间多一点，毕竟隔间是一兰的特色，坐屋台的话没有感觉。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548759269.jpeg" alt="一蘭拉面"><br>▲尖沙咀店一兰屋台 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759271.jpeg" alt="一蘭拉面"><br>▲一兰方便面 </p><p>一兰方便面，四五月份刚推出的时候有买单满200HKD送一个的活动，回来宿舍泡了一下发现挺一般的，跟店里吃的差距太大，不知道是方便面的问题还是我泡面方法不当[摊手]原价是198HKD五包，据说买一套的话里面会有特殊配料 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759272.jpeg" alt="一蘭拉面"><br>▲泡出来的效果，凭良心讲确实比合味道之类的好吃一些，但还不至于太好吃，不值那个价。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548759275.jpeg" alt="一蘭拉面"><br>▲方便面海报 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759279.jpeg" alt="一蘭拉面"><br>▲收银台 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759280.jpeg" alt="一蘭拉面"><br>▲收银台后面的展柜 </p><p>月初去吃的时候发现账单多了一项额外10%的服务费，以前都没见过，不知道是最近才开始收的还是因为尖沙咀店比较大要额外收费。付款支持现金、八达通和银联卡，我预计不用太久，支付宝就会来插一脚，进一步方便大陆游客在香港游玩。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759281.jpeg" alt="一蘭拉面"><br>▲尖沙咀店内海报 </p><p>还没读大学的时候在广州住，每次去正佳和中华基本上都是吃博多一幸舍。博多刚进驻广州第一次吃的时候震惊了，怎么会有这么好吃的面，从此再也没吃过味千公仔面。 然而上大学后，某次安利别人博多时被反安利了一兰，这才发觉山外有山。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548759282.jpeg" alt="一蘭拉面"><br>▲铜锣湾店门面 </p><p>一兰没有博多一幸舍的喧闹环境，店员们不会热血地齐声用日语喊欢迎光临，只会在隔间后面端面上来时说一声慢用（不会日语，猜的）然后落下帘子。店里如果没有小孩的话一般都挺安静。 另外不同于博多丰富的菜单，一兰只有一款面（好像最近新推出了一款沾面，不太记得了）。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548759283.jpeg" alt="一蘭拉面"><br>▲基友吃得正欢 </p><p>在我有限的经历中，一兰拉面在我吃过的日本拉面中算是最好吃的了，一兰以其独特的隔间设计，只做一款面的坚持，极致浓香的汤底，口感细腻的面底赢得了大众的喜爱。有时候我嘴馋了也不怕劳累，专门从深圳湾过关搭巴士到天水围转港铁到尖沙咀来吃个面，也算是一兰真粉了。 大家如果去一兰，一定要预留多一些时间用来排队，以免耽误行程。[doge] </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759283.jpeg" alt="一蘭拉面"></p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/85y8zF4qNyA2NR8sBmuNLQ" target="_blank" rel="noopener">一蘭拉面</a></p></blockquote><h3 id="2019-01更新-—-日本的一蘭拉面"><a href="#2019-01更新-—-日本的一蘭拉面" class="headerlink" title="2019.01更新 — 日本的一蘭拉面"></a>2019.01更新 — 日本的一蘭拉面</h3><p>  2018年夏天去大阪和东京晃悠了一圈，路过不少一兰。  </p><h3 id="大阪"><a href="#大阪" class="headerlink" title="大阪"></a>大阪</h3><h4 id><a href="#" class="headerlink" title=" "></a> </h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_2417.jpg" alt><br>▲大阪也超多人</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_7512.jpg" alt><br>▲自助机器先付后食，这种机器是真的🐂🍺   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_4485.jpg" alt><br>▲自助机出的票   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_4487.jpg" alt><br>▲出品稳定，跟香港的几乎没区别      </p><h3 id="东京"><a href="#东京" class="headerlink" title="东京"></a>东京</h3><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_7086.jpg" alt><br>▲还是自助机，依然人多得一批   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_5225.jpg" alt><br>▲还是一样的味道   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_5497.jpg" alt><br>▲一样的抹茶豆腐</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Food </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
